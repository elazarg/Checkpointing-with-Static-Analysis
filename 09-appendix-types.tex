\section{Type System}
\label{appendix:typesystem}
\section*{Appendix: Type System Formalization}

This appendix specifies the type system implemented in \texttt{type\_system.py}.  
It is designed to support precise static modeling of scientific Python code (e.g.\ NumPy, SciPy) while avoiding complexity unnecessary for the code bases we target.  
Notably, the system does \emph{not} implement nominal subtyping between user classes, even though class hierarchies are recorded. This is intentional: nominal subtyping in Python is subtle, and was not needed for our analyses.

\subsection{Syntax}

Type expressions $\mathcal{T}$ cover constants, variables (ordinary and variadic), unions, records, classes, modules, polymorphic functions, overloads, instantiations, and literal values.  
Record types $R$ map field keys $f$ to types, where keys can carry both positional and nominal components.  
Effects $\epsilon$ annotate callable types with allocation, mutation, and property metadata.

\begin{figure}[t]
\centering
\[
\begin{aligned}
\tau ::= \;& c \mid X \mid X^* \mid \ell \mid \tau_1 + \tau_2 \mid R \mid f : \tau \\
&\mid \mathsf{class}(C, R, \overline{\tau}, \overline{X}, \mathsf{protocol}?) \\
&\mid \mathsf{module}(M) \\
&\mid \forall \overline{X}.R \xrightarrow{\epsilon} \tau \mid \{\varphi_1, \ldots, \varphi_n\} \\
&\mid \tau\langle\overline{\tau}\rangle
\end{aligned}
\]
\[
R ::= \{f_1 : \tau_1, \ldots, f_n : \tau_n\}
\quad\quad
f ::= \langle i \rangle \mid \langle s \rangle \mid \langle i, s \rangle
\]
\[
\epsilon = (\mathsf{new} : \mathbb{B},\; \mathsf{method} : \mathbb{B},\; \mathsf{update} : \tau^?,\; \mathsf{pointsToArgs} : \mathbb{B})
\]
\caption{Syntax of types, records, field keys, and effects. $c$ ranges over qualified constants; $\ell$ over literal types; $X^*$ denotes variadic type variables.}
\label{fig:syntax}
\end{figure}

\paragraph{Examples.}  
\begin{itemize}
\item Function \texttt{def f(x: int, y: str = "d")} has type:
 \[\forall \{\}.\{\langle 0, \text{x} \rangle : \mathsf{int}, \langle 1, \text{y} \rangle : \mathsf{str}\} \xrightarrow{\epsilon_\mathsf{pure}} \mathsf{None}\]
\item Generic \texttt{list[int]} is $\mathsf{list}\langle\mathsf{int}\rangle$.
\item Class \texttt{Point} with fields \texttt{x: int, y: int} has record $\{\langle 0, \text{x} \rangle : \mathsf{int}, \langle 1, \text{y} \rangle : \mathsf{int}\}$.
\end{itemize}

\subsection{Static Semantics}

\paragraph{Type Environment.}  
$\Gamma$ maps names to types, and $\Delta$ maps type variables to bounds.

\paragraph{Subtyping.}  
Subtyping supports reflexivity and transitivity, union decomposition, record width/depth subtyping and structural subtyping for protocol classes.

There is \emph{no} nominal subtyping rule between arbitrary classes; two distinct non‐protocol classes are unrelated unless one is a union containing the other.

\begin{figure*}[t]
\centering
\[
\frac{}{\Gamma \vdash \tau <: \tau} \quad \text{(Refl)}
\qquad
\frac{\Gamma \vdash \tau_1 <: \tau_2 \quad \Gamma \vdash \tau_2 <: \tau_3}{\Gamma \vdash \tau_1 <: \tau_3} \quad \text{(Trans)}
\]
\[
\frac{\forall i. \Gamma \vdash \tau_i <: \tau}{\Gamma \vdash (\tau_1 + \cdots + \tau_n) <: \tau} \quad \text{(Union-Sub)}
\]
\[
\frac{\mathsf{dom}(R_2) \subseteq \mathsf{dom}(R_1) \quad \forall f \in \mathsf{dom}(R_2).\ \Gamma \vdash R_1(f) <: R_2(f)}{\Gamma \vdash R_1 <: R_2} \quad \text{(Record-Sub)}
\]
\[
\frac{\mathsf{protocol} = \mathsf{true} \quad \Gamma \vdash R_1 <: R_2}{\Gamma \vdash \mathsf{class}(C_1, R_1, \ldots, \mathsf{true}) <: \mathsf{class}(C_2, R_2, \ldots)} \quad \text{(Protocol)}
\]
\caption{Implemented subtyping rules.}
\label{fig:subtyping}
\end{figure*}

\paragraph{Type Operations.}  
Joins $\sqcup$ compute least upper bounds; meets $\sqcap$ compute greatest lower bounds.  
For records:  
\[
R_1 \sqcup R_2 = \{f : R_1(f) \sqcup R_2(f) \mid f \in \mathsf{dom}(R_1) \cap \mathsf{dom}(R_2)\}
\]
\[
R_1 \sqcap R_2 = \{f : R_1(f) \sqcap R_2(f) \mid f \in \mathsf{dom}(R_1) \cup \mathsf{dom}(R_2)\}
\]

Otherwise it is a straightforward union:
\[
\tau \sqcup \tau = \tau
\quad\quad
\tau_1 \sqcup \tau_2 = \tau_1 + \tau_2 \ \text{if unrelated}
\]

\paragraph{Unification.}  
Unification $\Delta \vdash \tau_1 \doteq \tau_2 \leadsto \theta$ computes substitutions $\theta : \mathcal{V} \to \mathcal{T}$, supports variadic parameters, instantiation, functions, and records.  
For functions, unification \emph{requires} side effects to be equal; they are not joined at this stage.

\begin{figure*}[t]
\centering
\[
\frac{X \notin \mathsf{dom}(\theta) \quad X \notin \mathsf{FV}(\tau)}{\Delta \vdash X \doteq \tau \leadsto \theta[X \mapsto \tau]} \quad \text{(Var-L)}
\]
\[
\frac{\Delta \vdash \overline{\tau_1} \doteq \overline{\tau_2} \leadsto \theta}{\Delta \vdash c\langle\overline{\tau_1}\rangle \doteq c\langle\overline{\tau_2}\rangle \leadsto \theta} \quad \text{(Inst)}
\]
\[
\frac{X \notin \mathsf{dom}(\theta) \quad \Delta \vdash \overline{\tau_1} \doteq \overline{\tau_2} \leadsto \theta'}{\Delta \vdash X\langle\overline{\tau_1}\rangle \doteq c\langle\overline{\tau_2}\rangle \leadsto \theta[X \mapsto c] \cup \theta'} \quad \text{(Inst-Var)}
\]
\[
\frac{X^* \notin \mathsf{dom}(\theta) \quad X^* \notin \mathsf{FV}(\tau_1, \ldots, \tau_n)}{\Delta \vdash X^* \doteq (\tau_1, \ldots, \tau_n) \leadsto \theta[X^* \mapsto (\tau_1, \ldots, \tau_n)]} \quad \text{(Var-Star)}
\]
\[
\frac{\Delta \vdash R_1 \doteq R_2 \leadsto \theta_1 \quad \Delta \vdash \tau_1 \doteq \tau_2 \leadsto \theta_2 \quad \epsilon_1 = \epsilon_2}{\Delta \vdash (R_1 \xrightarrow{\epsilon_1} \tau_1) \doteq (R_2 \xrightarrow{\epsilon_2} \tau_2) \leadsto \theta_1 \cup \theta_2} \quad \text{(Fun)}
\]
\[
\frac{\forall f_i \in \mathsf{common}(R_1, R_2).\ \Delta \vdash R_1(f_i) \doteq R_2(f_i) \leadsto \theta_i}{\Delta \vdash R_1 \doteq R_2 \leadsto \bigcup_i \theta_i} \quad \text{(Record)}
\]
\caption{Unification rules (function unification requires equal effects).}
\label{fig:unification}
\end{figure*}

\paragraph{Name Resolution.}  
Name resolution proceeds by current function (we only analyze standalone functions, so class-scope is irrelevant), then module‐local entries in the global module map $\mathcal{M}$, then builtins; otherwise it fails.

\subsection{Dynamic Semantics}

Dynamic semantics covers overload resolution, attribute/index access, and effect composition.

\paragraph{Overload Resolution.}  
Overloads are resolved by unifying parameters against argument types; all matching alternatives’ return types are joined.

\paragraph{Attribute and Index Access.}  
There is no dedicated $\tau.\ell$ syntax form; attribute/index access is an \emph{operation} performed by the interpreter:  
\begin{itemize}
\item If $\tau$ has a matching field in its record or class members, that type is returned.
\item Otherwise, if it has a \texttt{\_\_getitem\_\_} method, that method is applied to the index type.
\end{itemize}

\paragraph{Effects.}  
Effects join pointwise: $\epsilon_1 \sqcup_{\mathcal{E}} \epsilon_2$ 
takes the disjunction of each Boolean component and the optional join $\sqcup^?$ of their \texttt{update} types, where
\[
\tau_1^? \sqcup^? \tau_2^? =
\begin{cases}
\tau_1 \sqcup \tau_2 & \text{if both defined} \\
\tau_i & \text{if only } \tau_i \text{ defined} \\
\bot & \text{if neither defined}
\end{cases}
\]
The `property` concept is separate from effects: properties are modeled as functions with a dedicated \texttt{property} flag.

\begin{figure*}[t]
\centering
\textbf{Overload resolution:}
\[
\mathsf{resolve}(\{\varphi_1, \ldots, \varphi_n\}, \overline{\tau}) =
\bigsqcup\{\mathsf{return}(\varphi_i) \mid \mathsf{unify}(\mathsf{params}(\varphi_i), \overline{\tau}) \ \text{succeeds}\}
\]
\caption{Dynamic semantics: overload resolution (attribute/index access is operational).}
\label{fig:dynamic}
\end{figure*}

\paragraph{Integration with Analysis.}  
The type system supports:
\begin{itemize}
\item Heap shape modeling via record types $R$
\item Effect‐guided mutation and aliasing reasoning
\item Attribute and index resolution during abstract interpretation
\item Allocation site identification from $\epsilon.\mathsf{new}$
\item Row polymorphism for precise parameter passing semantics
\end{itemize}
