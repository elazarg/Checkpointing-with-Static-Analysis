\section{Type System}
\label{sec:appendix-typesystem}
\subsection{Background}
This appendix specifies the type system implemented in \texttt{type\_system.py}.  
It is designed to support precise static modeling of scientific Python code (e.g., NumPy, SciPy) while avoiding complexity unnecessary for scientific/numerical workloads with predictable control flow and limited reflection.
\paragraph{Design rationale.}
The system adopts several deliberate departures from common type-system practice, trading generality for domain-specific tractability:
\begin{itemize}
  \item \textbf{Uniform field/parameter handling:} Model both function parameters and class/protocol/module bindings as rows (ordered typed dictionaries), enabling uniform handling of lookup, subtyping, join, and unification with width-subtyping.
  \item \textbf{Variadic packs with incremental binding:} Allow pack variables to be partially instantiated and applied multiple times, mirroring Python's flexible calling conventions while leveraging the uniform row representation.
  \item \textbf{No nominal subtyping between user classes:} Avoid Python's method-resolution-order (MRO) complexity, which is unnecessary for scientific workloads.
  \item \textbf{Type effects with strict equality:} Annotate functions with effects for heap allocation, mutation, and argument type updates. Require equality rather than joins during function unification, prioritizing checkpointing precision over effect polymorphism.
  \item \textbf{Two-stage overload resolution:} First match parameter signatures, then join the return types of all successful matches, reflecting Python's runtime dispatch model.
\end{itemize}
\subsubsection*{Meta-properties and scope.}
While we do not prove formal soundness, the design aims for:
\begin{itemize}
  \item \textbf{Decidability:} Type checking and inference are decidable for the restricted Python fragment (Appendix~\ref{sec:appendix-assumptions}).
  \item \textbf{Termination:} Unification and join terminate over the targeted subset; the type lattice is finite and usually very short. Dimensionality tracking of NumPy arrays is intentionally excluded due to its termination and complexity implications.
  \item \textbf{Precision:} Strict effect equality and the information ordering favor simplicity and precise state reasoning over broad applicability.
  \item \textbf{Transparency:} The unknown type \textsf{any} and dynamic features act as explicit, unsound escape hatches.
\end{itemize}

\subsection{Syntax}
% TODO: which to use, \mathcal{T} or \tau and when?
Figure \ref{fig:type-syntax} defines the syntax of the type system. Type expressions $\mathcal{T}$ cover constants, variables (both ordinary and variadic), unions, records, classes, modules, polymorphic functions, overloads, instantiations, and literal values.  
Record types map field keys to types, where keys may carry both positional and nominal components.  
Effects annotate callable types with allocation and mutation.

\paragraph{Uniform use of rows.}
Rows~$\rho$ are the \emph{only} finite mapping construct in the type system, used both for
callable parameter lists and for class/module member dictionaries (see §\ref{sec:unified-record}).  
In Python, both are naturally modeled as ordered typed dictionaries: finite maps from
\emph{keys} (either positional indices or string labels) to types, with ordering
preserved from their definition.  
This uniform abstraction allows the same operations --- $\mathsf{unify}_{\rho}$, subtyping, join/meet (Fig.~\ref{fig:auxiliary-defs}) --- to apply in both contexts,  
simplifying the formalism and aligning with the structural nature of Python's
attribute and parameter matching rules.

\noindent
In our setting, parameter rows are not a distinct syntactic category from record rows: both are instances of the same $\rho$ syntax, so parameter–argument unification is literally the same fieldwise unification used for member records.  
The only difference is in the \emph{interpretation}:
for arguments, missing keys may indicate partial application;
for parameters, missing keys indicate an invalid call;
for fields, missing keys indicate absent attributes (yielding~$\bot$ on lookup).

The syntax of the type system is given in Figures~\ref{fig:metavars} and~\ref{fig:type-syntax}.
% ==== Row macros (safe in subscripts/superscripts) ====
\newcommand{\rpos}{\mathord{\rho^{+}}}   % arguments, fields
\newcommand{\rneg}{\mathord{\rho^{-}}}   % parameters
\newcommand{\rdef}{\mathord{\rho^{=}}}   % defaults
\newcommand{\rowany}{\mathord{\rho}}     % generic row metavariable

\begin{figure}[t]
\centering
\[
\begin{array}{ll}
X, Y, Z & \text{type variables} \\
i & \text{positional index} \in \mathbb{N} \\
s & \text{string label} \in \mathcal{L} \\
\rho & \text{generic row variable (unspecified polarity)} \\
\rpos & \text{argument row (positive)} \\
\rneg & \text{parameter row (negative)} \\
\rdef & \text{default-argument row (positive)}
\end{array}
\]
\caption{Metavariables for row kinds and related constructs.}
\label{fig:metavars}
\end{figure}

\begin{figure}[t]
\centering
\begin{align*}
\tau ::=~& c \quad\text{(qualified constant name)} \\
 & \mid \ell \quad\text{(literal type)} \\
 & \mid \mathsf{union}(\overline{\tau}) \\
 & \mid \mathsf{module}(C, \rowany) \\
 & \mid \mathsf{protocol}(\rowany, \overline{\tau}, \overline{X}) \\
 & \mid \mathsf{class}(C, \rowany, \overline{\tau}, \overline{X}) \\
 & \mid \mathsf{overload}(\overline{F}) \\
 & \mid \tau\langle\overline{\tau}\rangle \quad\text{(generic instantiation)} \\
 & \mid X \mid X^* \mid \mathsf{star}(\overline{\tau}) \\
 & \mid \mathsf{any}
\\[0.5em]
\rowany ::=~& \{ k_1 : \tau_1, \ldots, k_n : \tau_n \} \quad\text{(ordered typed dictionary)}
\\[0.5em]
F ::=~& \forall \overline{X}.\,\rneg \mid \rdef \xrightarrow{\epsilon} \tau
\quad\text{(function signature)}\\
 & \mid \forall \overline{X}\xrightarrow{\epsilon} \tau \quad\text{(property signature)}
\\
k ::=~& \langle i\rangle \mid \langle s\rangle \mid \langle i, s\rangle
\quad\text{(field key)}
\end{align*}
\caption{Type system syntax. Effects $\epsilon$ are described in \autoref{sec:effects}.}
\label{fig:type-syntax}
\end{figure}

\paragraph{Design note.}
Effects~$\epsilon$ are \emph{not} row-polymorphic: unification is only applied to positive rows, and unification of callables requires $\epsilon_1 = \epsilon_2$.  
This sacrifices the flexibility of row-polymorphic effect systems in exchange for higher precision in mutation and allocation tracking, which is critical to our checkpointing analysis.

\subsection{Unified Row Model}
\label{sec:unified-record}
We use a single, uniform construct~$\rho$ to model all finite, ordered key--type mappings in Python.
Rows appear in different \emph{roles} (arguments/fields vs.\ parameters), but they share the \emph{same} width-based order and lattice; variance is handled at function types.


\begin{figure*}[t]
\centering
\[
\begin{array}{c}
\displaystyle
\frac{
  \mathsf{posrow}(\rpos_A) \quad
  \mathsf{matchRows}(\forall\overline{X}.\rneg \mid \rdef,\ \rpos_A) \Downarrow (\theta, \rneg')
}{
  \forall\overline{X}.~\rneg \mid \rdef \xrightarrow{\ \epsilon\ } \tau
  \ \triangleright\ 
  \rpos_A
  \ \Downarrow\
  \forall(\overline{X}\setminus\mathrm{dom}(\theta)).~
  \rneg' \mid \rdef'
  \xrightarrow{\ \mathsf{project}(\epsilon[\theta],\,\rneg')\ }
  \tau[\theta]
}
\quad \textsc{(PartialApp)}
\\[1.5em]

\displaystyle
\frac{
  \mathsf{matchRows}(\rdef,\ \rneg_{\mathrm{rem}}) \Downarrow (\_,\ \varnothing)
}{
  \rneg_{\mathrm{rem}} \mid \rdef \xrightarrow{\ \epsilon\ } \tau \ \triangleright\ \varnothing \ \Downarrow\ \tau
}
\quad \textsc{(FinishApp)}
\\[1.5em]

\textbf{Auxiliary} \\[0.5em]
\begin{array}{ll}
\mathsf{posrow}(\rpos) & \mathrm{dom}(\rpos)\cap\mathbb{N}=\{0,\dots,n{-}1\} \\
\text{Argument compatibility} & \tau_a \leq: \tau_p \\
\mathsf{matchRows}(\forall\overline{X}.\rneg,\ \rpos)\Downarrow(\theta,\rneg') &
\begin{array}[t]{@{}l@{}}
\mathrm{dom}(\rpos) \subseteq \mathrm{dom}(\rneg)\ \wedge \forall k\in\mathrm{dom}(\rpos).\ \rpos_k \leq: \rneg_k[\theta],\ \\
\text{with }\rneg' = \mathsf{residual}(\rpos[\theta],\rneg).
\end{array}
\\
\mathsf{residual}(\rpos,\rneg) & \mathsf{subtract\_indices}(\rneg \setminus \mathrm{dom}(\rpos),\ \mathrm{dom}(\rpos)\cap\mathbb{N}) \\
\mathsf{project}(\epsilon,\rneg) & \text{drop/rename parameter-indexed components to match }\rneg \\
\end{array}
\end{array}
\]
\caption{Typing rules for function application, supporting partial application and default arguments in Python’s calling model. \textsc{PartialApp} specializes parameters with arguments; \textsc{FinishApp} fires when remaining parameters are all satisfied by defaults.}
\label{fig:app-rules}
\end{figure*}

\paragraph{Keys.}
A key $k$ is composite: a parameter \texttt{x} at position $0$ is $\langle 0,\text{"x"} \rangle$; a class attribute \texttt{y} is $\langle \text{"y"} \rangle$.
Key compatibility:
\[
\langle k \rangle \preccurlyeq \langle k \rangle,\quad
\langle k \rangle \preccurlyeq \langle k, \_ \rangle,\quad
\langle k \rangle \preccurlyeq \langle \_, k \rangle.
\]

\paragraph{Row syntax.}
\[
\rho \;=\; \{\, k_1 : \tau_1,\ \dots,\ k_n : \tau_n \,\}
\]
Keys are unique; ordering is preserved for positional correctness.

\paragraph{Well-formedness.}
Let $\mathrm{dom}(\rho)$ be the set of keys in $\rho$.
\begin{align}
\mathsf{wellformed}(\rho) \;\equiv\;&
\big(\forall i<j.\ \langle i\rangle,\langle j\rangle \in \mathrm{dom}(\rho) \Rightarrow \langle i{-}1\rangle \in \mathrm{dom}(\rho)\big)\ \wedge\ 
\big(\forall k\in\mathrm{dom}(\rho).\ \mathsf{wellformed}(\rho(k))\big).
\end{align}
Contiguous-position predicate:
\[
\mathsf{posrow}(\rho) \;\equiv\; \mathrm{dom}(\rho)\cap\mathbb{N} \;=\; \{0,\dots,n{-}1\}\ \text{for some } n.
\]

\paragraph{Row order (width subtyping).}
Rows use a single width/depth order:
\begin{align*}
\rho_1 \;\le_\rho\; \rho_2 \;\;\iff\;\;
& \mathrm{dom}(\rho_2)\subseteq \mathrm{dom}(\rho_1) \\
\wedge \; & \forall k\in\mathrm{dom}(\rho_2).\ \rho_1(k)\ \le\ \rho_2(k)
\end{align*}
Intuition: more keys and/or more specific member types $\Rightarrow$ a more specific row.

\paragraph{Row lattice.}
Rows form a lattice $(\mathcal{R}, \le_\rho, \sqcup_\rho, \sqcap_\rho, \top_\rho, \bot_\rho)$:
\[
\begin{array}{lcl}
\top_\rho &=& \{\}\ \ \text{(empty row)}\\[0.2em]
\bot_\rho &=& \text{inconsistent row}\\[0.2em]
\mathrm{dom}(\rho_1 \sqcup_\rho \rho_2) &=& \mathrm{dom}(\rho_1)\cap\mathrm{dom}(\rho_2)\\
(\rho_1 \sqcup_\rho \rho_2)[k] &=& \rho_1[k]\ \sqcup\ \rho_2[k]\quad (k\ \text{shared})\\[0.2em]
\mathrm{dom}(\rho_1 \sqcap_\rho \rho_2) &=& \mathrm{dom}(\rho_1)\cup\mathrm{dom}(\rho_2)\\
(\rho_1 \sqcap_\rho \rho_2)[k] &=& \rho_1[k]\ \sqcap\ \rho_2[k]\quad (k\ \text{shared})
\end{array}
\]

\paragraph{Function variance (where contravariance lives).}
Contravariance arises at the function constructor:
\[
(\rho_1 \xrightarrow{\epsilon} \tau_1)\ \le\ (\rho_2 \xrightarrow{\epsilon} \tau_2)
\quad\iff\quad
\rho_2\ \le_\rho\ \rho_1\ \ \wedge\ \ \tau_1\ \le\ \tau_2.
\]
(Effects are compared as specified elsewhere; we require $\epsilon$ equality in our implementation.)

\paragraph{Protocols (structural).}
Let $\Pi[\overline{\sigma}]$ have required row $R_\Pi$ (after instantiation), and let $R_T$ be the provided member row of $T$.
Then
\begin{align*}
\Gamma \vdash T \;<:\; \Pi[\overline{\sigma}] \quad\iff & \mathrm{dom}(R_\Pi)\subseteq \mathrm{dom}(R_T) \\
\wedge \; & \forall k\in\mathrm{dom}(R_\Pi).\ \Gamma \vdash R_T(k)\ <: \ R_\Pi(k)
\end{align*}

with method members checked by the function subtyping rule above.

\subsection{Type Parametricity}
Given $\forall\overline{X}.\,\rneg \mid \rdef \xrightarrow{\epsilon} \tau_r$ and arguments $\rpos_A$:

\paragraph{Binding.}
$(\theta, \rneg') = \mathsf{matchRows}(\forall\overline{X}.\rneg,\rpos_A)$.

\paragraph{Effects.}
Apply $\theta$ to $\epsilon$, then $\mathsf{project}$ to $\rneg'$.

\paragraph{Residual.} $\forall(\overline{X} \setminus \mathrm{dom}(\theta)).~\rneg' \mid \rdef' \xrightarrow{\epsilon'} \tau_r[\theta]$
where $\rdef'$ is $\rdef$ restricted/reindexed to $\rneg'$.

\paragraph{Finish.}
If $\mathsf{matchRows}(\rdef,\rneg')$ has empty residual, return $\tau_r[\theta]$.

\subsection{Variadic Packs}
If $\rneg$ has one variadic positional $i:X^*$:
\begin{enumerate}
  \item Bind fixed params first.
  \item Match remaining contiguous positionals to $X^*$.
  \item Retain $X^*$ in $\rneg'$ for incremental binding in later applications.
\end{enumerate}

\subsection{Overloads}
For overload $\{\varphi_1,\dots,\varphi_m\}$ and $\rpos_A$:
\begin{itemize}
  \item Bind each case independently.
  \item Discard failures; group by identical matched-parameter sets.
  \item Each group becomes an overloaded residual callable.
  \item If all \textsf{FinishApp} is applicable to all residuals, join their return types.
\end{itemize}

\subsection{Receiver Binding}
\label{sec:receiver-binding}
Methods have first parameter as receiver:
\[
\forall \overline{X}.\,(0:\tau_{\mathit{self}},\,\rneg') \mid \rdef \xrightarrow{\epsilon} \tau_r
\]
Bind receiver, drop/reindex, continue as partial application.

\paragraph{Arity.}
Unmatched arguments $\to$ error; unmatched parameters $\to$ residual callable (possibly discharged by defaults).

\subsection{Example}
To illustrate partial application, consider a generic function taking two parameters. Let:
\[
\varphi = \forall T,U.~(0:T,\,1:U) \mid \{\} \xrightarrow{\epsilon} T
\]
Apply $\{0:\mathsf{int}\}$:
\[
\theta=\{T\mapsto \mathsf{int}\},\quad \rneg'=\{0:U\}
\]
Residual: $\forall U.~(0:U) \mid \{\} \xrightarrow{\epsilon[\theta]} \mathsf{int}$.

Apply $\{0:\mathsf{str}\}$:
\[
\theta'=\{U\mapsto \mathsf{str}\}
\]
Now \textsf{FinishApp} is applicable, so $\Rightarrow \mathsf{int}$.

\subsection{Modules, Classes, and Protocols}
\label{sec:modules-classes-protocols}

\paragraph{Entity differences.}
We distinguish three entity forms:
\begin{itemize}
    \item \textbf{Classes} are nominal in that they do not support structural subtyping: two classes are related if and only if they have \emph{exactly} the same name (and their type parameters can be unified). We model no nontrivial superclass relations. Class members are given by a row~$\rho$; classes may be generic over type parameters~$\overline{\alpha}$.
    \item \textbf{Modules} are singletons: a module $\mathsf{module}(C, \rho)$ has a fixed row of members and no generic parameters.
    \item \textbf{Protocols} are structural interfaces with optional type parameters. Satisfaction is by structural subtyping (\S\ref{fig:subtyping}), not by nominal identity.
\end{itemize}

\paragraph{Common mechanism: member access.}
All three entity kinds share the same lookup mechanism on their member row~$\rho$ (see \S\ref{sec:unified-record}).  
Given an entity type~$\tau$ and a key~$k$ (positional index or string label; cf.\ Fig.~\ref{fig:metavars}), the lookup judgment
\[
\tau \cdot k \Downarrow v
\]
yields the member type~$v$ or $\bot$ if no match is found.

Lookup is defined as:
\begin{align*}
\rho \cdot k &= \bigsqcup \{\tau \mid k'{:}\tau \in \rho \ \wedge\ k' <: k \}
  &&\text{(basic case; $\bot$ if no match)}\\
(\tau_1 + \tau_2) \cdot k &= (\tau_1 \cdot k) \ \sqcup\ (\tau_2 \cdot k)
  &&\text{(union types)} \\
\mathsf{module}(C, \rho) \cdot k &= \rho \cdot k
  &&\text{(modules)}\\
\mathsf{class}(C, \rho, \overline{\tau}, \overline{X}) \cdot k &= \rho \cdot k
  &&\text{(classes)}\\
C[\overline{\sigma}] \cdot k &= (\mathsf{class}(C, \rho, \overline{\alpha}, \overline{X})[\alpha_i \mapsto \sigma_i]) \cdot k
  &&\text{(instantiated classes)}
\end{align*}

If $\rho \cdot k$ yields an overload set, the overload combination rules of \S\ref{sec:overload-resolution} apply.  
If the member is callable, receiver binding (\S\ref{sec:receiver-binding}) is applied, treating the receiver as the first positional argument~$\langle 0\rangle$.  
If the member is a property, the property-access rule applies.

\paragraph{Generic classes.}
A generic class type has the form
\[
\mathsf{class}(C, \rho, \overline{\alpha}, \overline{X})
\]
where $\overline{\alpha} = (\alpha_1,\dots,\alpha_m)$ are type parameters and $\rho$ is the member row.

\emph{Instantiation:} Given $\overline{\sigma}$ with $|\overline{\sigma}| = m$,
\[
C[\overline{\sigma}] = (\mathsf{class}(C, \rho, \overline{\alpha}, \overline{X}))[\alpha_i \mapsto \sigma_i]_{i=1}^m
\]
Substitution applies to all member types and to any effects:
\[
(\rho \xrightarrow{\epsilon} \tau)[\alpha \mapsto \sigma] \;=\; (\rho[\alpha \mapsto \sigma]) \xrightarrow{\epsilon[\alpha \mapsto \sigma]} (\tau[\alpha \mapsto \sigma]).
\]
Class parameters are in scope for all members.

\paragraph{Method parameter shadowing.}
If a method is quantified $\forall\overline{\beta}.\,\rho \xrightarrow{\epsilon} \tau$ and $\overline{\beta} \cap \overline{\alpha} \neq \varnothing$, each $\beta_i$ shadows the corresponding $\alpha_j$ within the method’s scope; no automatic renaming is performed.

\paragraph{Protocols.}
A protocol $\Pi[\overline{\alpha}]: \rho$ is a structural interface.
A type $T$ satisfies $\Pi[\overline{\sigma}]$ iff, writing $R_\Pi$ for the instantiated requirement row and $R_T$ for the provided member row of $T$:
\[
\mathrm{dom}(R_\Pi) \subseteq \mathrm{dom}(R_T)
\quad\text{and}\quad
\forall k \in \mathrm{dom}(R_\Pi).\ \Gamma \vdash R_T(k) \;<:\; R_\Pi(k),
\]
where method members are checked by function subtyping (parameters contravariant, result covariant). Protocol type parameters are instantiated with $\overline{\sigma}$ before checking satisfaction.

\paragraph{Lattice structure of rows.}
As in \S\ref{sec:unified-record}, rows form a lattice $(\mathcal{\rho}, \sqsubseteq, \sqcup, \sqcap, \top, \bot)$ under the information ordering: more keys $\Rightarrow$ more specific.
\begin{itemize}
  \item $\top_\rho$ = empty row
  \item $\bot_\rho$ = inconsistent row
  \item \textbf{Join} ($\sqcup$): intersection of domains, join types pointwise (join as in Fig.~\ref{fig:auxiliary-defs})
  \item \textbf{Meet} ($\sqcap$): union of domains, meet types pointwise
\end{itemize}

\paragraph{Worked example.}
\[
\begin{aligned}
\text{Definition:} \quad & \mathsf{class}\; \mathsf{List}[T] :
\\ & \{\langle \mathrm{"append"} \rangle : (\mathrm{self}:\mathsf{List}[T],\ x:T) \xrightarrow{\epsilon} \mathsf{None} \} \\[0.5em]
\text{Instantiation:} \quad & \mathsf{List}[\mathsf{int}] =
\\ & \{\langle \mathrm{"append"} \rangle : (\mathrm{self}:\mathsf{List}[\mathsf{int}],\ x:\mathsf{int}) \xrightarrow{\epsilon} \mathsf{None} \} \\[0.5em]
\text{Lookup:} \quad & \mathsf{List}[\mathsf{int}] \cdot \langle \mathrm{"append"} \rangle =
\\ & (\mathrm{self}:\mathsf{List}[\mathsf{int}],\ x:\mathsf{int}) \xrightarrow{\epsilon} \mathsf{None} \\[0.5em]
\text{Bind self:} \quad & \langle x\rangle:\mathsf{int} \;\xrightarrow{\epsilon}\; \mathsf{None}
\end{aligned}
\]

\begin{figure}[t]
\centering
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l}
\multicolumn{2}{l}{\textbf{Auxiliary Definitions}} \\[0.3em]
$\mathrm{dom}(\rho)$ & Domain of keys in row $\rho$ \\
$\rho \cdot k$ & Lookup type at key $k$ in $\rho$ ($\bot$ if absent) \\
$\rho[k \mapsto \tau]$ & Row update (replace or insert key $k$ with type $\tau$) \\
$\rho \setminus S$ & Row with all keys in $S$ removed \\
$k \preccurlyeq k'$ & Key match: $\langle k \rangle \preccurlyeq \langle k \rangle; \langle k \rangle \preccurlyeq \langle k, _ \rangle; \langle k \rangle \preccurlyeq \langle _, k \rangle$ \\
$\theta[\tau]$ & Capture-avoiding substitution of $\theta$ into $\tau$ \\
$\theta_1 \sqcup \theta_2$ & Substitution join: defined iff same RHS for overlapping vars (up to $\alpha$) \\
$R_1 \sqcup R_2$ & Row join: keep common keys, join their types \\
$R_1 \sqcap R_2$ & Row meet: union of keys, meet their types \\
$\mathsf{unify}_{\mathrm{type}}(\tau_1,\tau_2)$ & Binary type unification (Fig.~\ref{fig:unification}) \\
$\mathsf{unify}_{\rho}(\rho_1,\rho_2)$ & Field-wise unification on $\mathrm{dom}(\rho_1) \cap \mathrm{dom}(\rho_2)$
\end{tabular}
\caption{Common predicates and operations for member access and structural satisfaction.}
\label{fig:auxiliary-defs}
\end{figure}

\subsection{Static Semantics}
\label{subsec:static-semantics}

\paragraph{Scope and soundness.}
The typing rules are intended to be sound for the restricted Python subset
defined in Appendix \ref{sec:appendix-assumptions}, but we make no claims for full Python.
Features such as \textsf{any} and dynamic attribute creation are explicitly
unsound escape hatches, admitted for practicality in scientific code.  
All rules are designed to ensure decidable type checking and termination of unification
within the targeted subset.
\begin{figure*}[t]
\centering
\[
\begin{array}{c}
\textbf{Expression Typing } \Gamma \vdash e : \tau \\[1em]

\displaystyle\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau} \quad \textsc{(Var)}
\qquad
\displaystyle\frac{}{\Gamma \vdash v : \mathsf{Literal}(v)} \quad \textsc{(Literal)}
\\[1.5em]

\displaystyle\frac{\Gamma \vdash e : \tau \quad \tau \cdot a \Downarrow \phi \quad \phi \text{ is not callable}}{\Gamma \vdash e.a : \phi} \quad \textsc{(Member-Field)}
\\[1.5em]

\displaystyle\frac{\Gamma \vdash e : \tau \quad \tau \cdot a \Downarrow \forall\overline{X}.(0:\tau_{\mathit{self}}, R') \xrightarrow{\epsilon} \sigma \quad \mathsf{bind\_self}(\tau, \tau_{\mathit{self}}, R', \overline{X}) = (R'', \overline{Y}, \theta)}{\Gamma \vdash e.a : \forall\overline{Y}.R'' \xrightarrow{\epsilon[\theta]} \sigma[\theta]} \quad \textsc{(Member-Method)}
\\[1.5em]

\displaystyle\frac{\Gamma \vdash e : \tau \quad \tau \cdot a \Downarrow \forall() \xrightarrow \sigma}{\Gamma \vdash e.a : \sigma} \quad \textsc{(Member-Property)}
\\[1.5em]

\displaystyle\frac{\Gamma \vdash e : \mathsf{type}[C[\overline{\alpha}]] \quad \Gamma \vdash \tau_i : \mathsf{type}[T_i] \text{ for } i \in 1..n}{\Gamma \vdash e[\tau_1, \ldots, \tau_n] : \mathsf{type}[C[T_1, \ldots, T_n]]} \quad \textsc{(Type-Inst)}
\\[1.5em]

\displaystyle\frac{\Gamma \vdash e : \tau \quad \Gamma \vdash e_i : \tau_i \quad \mathsf{subscr}(\tau, \tau_i) = \sigma}{\Gamma \vdash e[e_i] : \sigma} \quad \textsc{(Subscript)}
\\[1.5em]

\displaystyle\frac{\Gamma \vdash e_1 : \tau_1 \quad \Gamma \vdash e_2 : \tau_2 \quad \mathsf{binop}(\tau_1, \mathit{op}, \tau_2) = \sigma}{\Gamma \vdash e_1 \mathit{\,op\,} e_2 : \sigma} \quad \textsc{(BinOp)}
\\[1.5em]

\displaystyle\frac{\Gamma \vdash e : \tau \quad \mathsf{unop}(\mathit{op}, \tau) = \sigma}{\Gamma \vdash \mathit{op}\, e : \sigma} \quad \textsc{(UnOp)}
\\[2em]

\textbf{Auxiliary Operations} \\[0.5em]
\begin{array}{ll}
\tau \cdot a \Downarrow \phi & \text{Member lookup (\S\ref{sec:rows-generic-access})} \\
\mathsf{bind\_self}(\tau_{\mathit{recv}}, \tau_{\mathit{self}}, R, \overline{X}) & \text{Receiver binding (\S\ref{sec:receiver-binding})} \\
\mathsf{property}(\phi) & \text{Predicate: callable flagged as a property} \\
\mathsf{subscr}(\tau, \tau_i) & \text{Subscript via fields or \_\_getitem\_\_ (\S\ref{sec:rows-generic-access})} \\
\mathsf{binop}(\tau_1, \mathit{op}, \tau_2) & \text{Two-step: } \tau_1 \cdot \langle\mathtt{"\_\_}\mathit{op}\mathtt{\_\_"}\rangle \triangleright \{0:\tau_2\} \text{ (via \textsc{PartialApp})} \\
\mathsf{unop}(\mathit{op}, \tau) & \text{Two-step: } \tau \cdot \langle\mathtt{"\_\_}\mathit{op}\mathtt{\_\_"}\rangle \triangleright \{\} \text{ (via \textsc{PartialApp})}
\end{array}
\end{array}
\]
\caption{Expression typing rules and row-level application. Constructor calls follow the same scheme after resolving the constructor protocol (e.g., \(\mathtt{\_\_init\_\_}\)). Effects are forwarded to the reduced product domain; the relation here returns only types.}
\label{fig:typing-rules}
\end{figure*}

Typing judgments are described in Figure \ref{fig:typing-rules}.

\paragraph{Binary and unary operations.}
Binary and unary operations are resolved through a two-step process that makes dunder method lookup explicit. For binary operations $e_1 \mathit{\,op\,} e_2$: first, the appropriate dunder method (e.g., \texttt{\_\_add\_\_} for \texttt{+}) is looked up on the left operand type via member access; second, the \textsc{PartialApp} rule is applied with the right operand as argument. Unary operations follow the same pattern but with no arguments. This approach unifies operator overloading with the general function application mechanism. Effects (allocation, mutation, aliasing) are extracted from the resolved function type and forwarded to the analysis domain, while the typing rules above show only the return types.

\paragraph{Subtyping.}  
Subtyping supports reflexivity, transitivity, union decomposition, record width/depth subtyping, and structural subtyping for protocols.  
There is \emph{no} nominal subtyping rule between arbitrary classes; two distinct non-protocol classes are unrelated unless one is a union containing the other.  
Protocol satisfaction is checked structurally: a type $T$ is a subtype of $\Pi[\overline{\sigma}]$ if it has all required members and each member type unifies (fieldwise) with the corresponding protocol member type.

\begin{figure*}[t]
\centering
\[
\frac{}{\Gamma \vdash \tau <: \tau} \quad \text{(Refl)}
\qquad
\frac{\Gamma \vdash \tau_1 <: \tau_2 \quad \Gamma \vdash \tau_2 <: \tau_3}{\Gamma \vdash \tau_1 <: \tau_3} \quad \text{(Trans)}
\]
\[
\frac{\forall i.\ \Gamma \vdash \tau_i <: \tau}{\Gamma \vdash (\tau_1 + \cdots + \tau_n) <: \tau} \quad \text{(Union-Sub)}
\]
\[
\frac{\mathrm{dom}(R_2) \subseteq \mathrm{dom}(R_1) \quad \forall k \in \mathrm{dom}(R_2).\ \Gamma \vdash R_1(k) <: R_2(k)}
     {\Gamma \vdash R_1 <:_\rho R_2} \quad \text{(Record-Sub)}
\]
\[
\frac{\mathrm{dom}(R_{\Pi[\overline{\sigma}]}) \subseteq \mathrm{dom}(R_T)
      \quad \forall k \in \mathrm{dom}(R_{\Pi[\overline{\sigma}]})\ .\ \Gamma \vdash R_T(k) \;<:\; (R_{\Pi[\overline{\sigma}]}\!)(k)}
     {\Gamma \vdash T \;<:\; \Pi[\overline{\sigma}]} \quad \text{(Protocol)}
\]
\caption{Implemented subtyping rules. Rows use $\mathrm{dom}$ and $<:_\rho$ as in \S\ref{sec:unified-record}. Protocol satisfaction is structural, using member access + $\mathsf{unify}_{\rho}$.}
\label{fig:subtyping}
\end{figure*}

\paragraph{Relation to width subtyping.}
Our information ordering, where $\rho$ rows with more fields are more specific, is
equivalent to the standard \emph{width subtyping} relation from record calculi
\cite{cardelli1992extensible}. This correspondence ensures that meet and join operations
behave predictably, while our strict key-matching rule simplifies unification and
lattice reasoning at the cost of omitting Python’s permissive keyword matching.

\paragraph{Type operations.}  
Joins~$\sqcup$ compute least upper bounds; meets~$\sqcap$ compute greatest lower bounds.  
For $\rho$ rows, these are as in Fig.~\ref{fig:auxiliary-defs}; otherwise joins are simple unions.

In the implementation, union types are \emph{normalized} after construction: duplicates are removed, nested unions are flattened, and singleton unions collapse to the member type.  
This normalization ensures canonical forms for lattice comparisons and avoids spurious distinctions between equivalent unions.

\paragraph{Quantified function application.}
Application of a quantified function $\forall\overline{X}.~\rho \xrightarrow{\epsilon} \tau_r$
is governed by the binding algorithm in Appendix~\ref{sec:receiver-binding},
which handles instantiation, partial application, variadic packs, overloads, and receiver binding.
\paragraph{Unification.}  
Unification $\Delta \vdash \tau_1 \doteq \tau_2 \leadsto \theta$ computes substitutions $\theta : \mathcal{V} \to \mathcal{T}$ and supports variadic parameters, instantiation, functions, and $\rho$ rows.  
For functions, unification \emph{requires} $\epsilon_1 = \epsilon_2$; effects are not joined at this stage.  
For other structured types such as unions or classes, unification proceeds componentwise over their parameters, and is \emph{undefined} when type constructors differ.

\begin{figure*}[t]
\centering
\[
\frac{X \notin \mathsf{dom}(\theta) \quad X \notin \mathsf{FV}(\tau)}
     {\Delta \vdash X \doteq \tau \leadsto \theta[X \mapsto \tau]} \quad \text{(Var-L)}
\]
\[
\frac{\Delta \vdash \overline{\tau_1} \doteq \overline{\tau_2} \leadsto \theta}
     {\Delta \vdash c\langle\overline{\tau_1}\rangle \doteq c\langle\overline{\tau_2}\rangle \leadsto \theta} \quad \text{(Inst)}
\]
\[
\frac{X \notin \mathsf{dom}(\theta) \quad \Delta \vdash \overline{\tau_1} \doteq \overline{\tau_2} \leadsto \theta'}
     {\Delta \vdash X\langle\overline{\tau_1}\rangle \doteq c\langle\overline{\tau_2}\rangle \leadsto \theta[X \mapsto c] \cup \theta'} \quad \text{(Inst-Var)}
\]
\[
\frac{X^* \notin \mathsf{dom}(\theta) \quad X^* \notin \mathsf{FV}(\tau_1, \ldots, \tau_n)}
     {\Delta \vdash X^* \doteq \mathsf{star}(\overline{\tau}) \leadsto \theta[X^* \mapsto \mathsf{star}(\overline{\tau})]} \quad \text{(Var-Star)}
\]
\[
\frac{\Delta \vdash R_1 \mathrel{\mathsf{unify}_{\rho}} R_2 \leadsto \theta_1 \quad \Delta \vdash \tau_1 \doteq \tau_2 \leadsto \theta_2 \quad \epsilon_1 = \epsilon_2}
     {\Delta \vdash (R_1 \xrightarrow{\epsilon_1} \tau_1) \doteq (R_2 \xrightarrow{\epsilon_2} \tau_2) \leadsto \theta_1 \cup \theta_2} \quad \text{(Fun)}
\]
\[
\frac{\forall k \in \mathrm{dom}(R_1) \cap \mathrm{dom}(R_2).\ \Delta \vdash R_1(k) \doteq R_2(k) \leadsto \theta_k}
     {\Delta \vdash R_1 \mathrel{\mathsf{unify}_{\rho}} R_2 \leadsto \bigsqcup_k \theta_k} \quad \text{(Record)}
\]
\caption{Unification rules, using $\mathrm{dom}$ and fieldwise $\mathsf{unify}_{\rho}$ as in \S\ref{sec:unified-record}. Function unification requires equal effects; other structured types (e.g., unions, classes) are unified componentwise. Unification is undefined when type constructors differ.}
\label{fig:unification}
\end{figure*}

\noindent\textbf{Note:} The strict effect-equality requirement matches the implementation’s precision goals in checkpointing analysis; other systems might use effect joins or subeffect relations.

\subsection{Dynamic Semantics}

Dynamic semantics here covers the runtime-analogous steps for overload resolution, attribute/index access, and effect composition, as modeled in our abstract interpreter.

\paragraph{Property evaluation.}
If $\tau \cdot k$ yields a callable $(\xrightarrow{\epsilon} \sigma)$, 
the result of $\tau \cdot k$ is $\sigma$ (implicit call with empty arguments).  
Otherwise, if it is callable but not a property, $\tau \cdot k$ yields the bound method, with the receiver already bound via the mechanism described in \S\ref{sec:receiver-binding}.

\paragraph{Overload resolution.}
\label{sec:overload-resolution}
Overload resolution is a two-stage process:
\begin{enumerate}
\item \textbf{Static grouping:}  
  Given an overload set $\{\varphi_1, \ldots, \varphi_n\}$ (e.g., from $\tau \cdot k$), each arm $\varphi_i$ is unified with the argument row $A$ via  
  $\mathsf{unify}_{\rho}(\mathsf{params}(\varphi_i), A)$ from \S\ref{sec:unified-record}.  
  Successful arms produce residual cases; these are grouped by identical matched-parameter sets, allowing partially applied overloads to be resolved without re-analyzing unrelated arms.
\item \textbf{Dynamic selection:}  
  At an actual call site, the saturated arms --- residuals where \textsf{FinishApp} is applicable --- from the relevant group are taken, and their return types are joined pointwise using the type join from Fig.~\ref{fig:auxiliary-defs}.
\end{enumerate}
This mirrors Python’s runtime dispatch but enables precise static joins over all viable arms.

\begin{figure*}[t]
\centering
\[
\mathsf{resolve}(\{\varphi_1, \ldots, \varphi_n\}, A) =
\bigsqcup\{\mathsf{return}(\varphi_i) \mid \mathsf{unify}_{\rho}(\mathsf{params}(\varphi_i), A) \ \text{succeeds}\}
\]
\caption{Dynamic-semantics view of overload resolution. $A$ is the argument row. $\bigsqcup$ is the type join from Fig.~\ref{fig:auxiliary-defs}.}
\label{fig:dynamic-semantics}
\end{figure*}

\paragraph{Attribute and index access.}  
\label{sec:rows-generic-access}
Attribute access $\tau \cdot k$ is resolved by the row lookup rules of \S\ref{sec:modules-classes-protocols}.  
Indexing $\tau[i]$ is modeled as:
\[
\tau[i] \;=\;
\begin{cases}
(\tau \cdot \langle i\rangle) & \text{if $\langle i\rangle \in \mathrm{dom}(\rho_\tau)$} \\[0.3em]
\mathsf{apply}(\tau \cdot \langle \mathrm{"\_\_getitem\_\_"}\rangle,\ \mathsf{type}(i)) & \text{otherwise}
\end{cases}
\]
where keys $\langle i\rangle$ and $\langle \mathrm{"\_\_getitem\_\_"}\rangle$ follow the syntax in Fig.~\ref{fig:metavars} and \S\ref{sec:unified-record}.

\subsubsection*{Effects}
\label{sec:effects}
An effect $\epsilon$ is a tuple
\[
\epsilon = (\mathsf{new},\ \mathsf{update},\ \mathsf{points\_to\_args},\ \mathsf{bound\_method})
\]
where:
\begin{itemize}
  \item $\mathsf{new} \in \{\mathsf{true},\mathsf{false}\}$ indicates allocation of a new object.
  \item $\mathsf{update} \in \mathcal{T}^?_{\rho}$ is an optional row type $\rho$ of updated fields.
  \item $\mathsf{points\_to\_args} \in \{\mathsf{true},\mathsf{false}\}$ indicates whether the result may point to arguments (used for aliasing).
  \item $\mathsf{bound\_method} \in \{\mathsf{true},\mathsf{false}\}$ marks bound methods produced by attribute access.
\end{itemize}

Effects form a finite product lattice $(\mathcal{E}, \sqsubseteq_{\mathcal{E}}, \sqcup_{\mathcal{E}}, \sqcap_{\mathcal{E}}, \top_{\mathcal{E}}, \bot_{\mathcal{E}})$.  
Joins are computed pointwise over Boolean components, and via an optional-type join $\sqcup^?$ for the $\mathsf{update}$ component:
\[
\tau_1^? \sqcup^? \tau_2^? =
\begin{cases}
\tau_1 \sqcup \tau_2 & \text{if both defined (join as in Fig.~\ref{fig:auxiliary-defs})},\\
\tau_i & \text{if only $\tau_i$ defined},\\
\bot & \text{if neither defined}.
\end{cases}
\]
If the $\mathsf{update}$ component is a row type $\rho$, its join is computed using the $\rho$-join rules from Fig.~\ref{fig:auxiliary-defs}.

\begin{table*}[ht]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Python Construct} & \textbf{Type Representation} & \textbf{Key Operations} \\
\hline
\texttt{def f(x: T) -> U} & $\forall\varnothing.\ \{0:T\} \mid \{\} \xrightarrow{\epsilon} U$ & Application, partial eval \\
\texttt{class C: ...} & $\mathsf{class}(C, \rho_{\mathit{members}}, [], [])$ & Member access, instantiation \\
\texttt{@property} & $\forall\varnothing.\ \xrightarrow{\epsilon} \tau$ & Auto-call on access \\
\texttt{@overload} & $\mathsf{overload}(\{\varphi_1, \ldots, \varphi_n\})$ & Two-stage resolution \\
\texttt{*args} & $\{i: X^*\}$ in params & Incremental binding \\
\texttt{x.attr} & $\tau \cdot \langle\text{``attr''}\rangle$ & Row lookup \\
\texttt{x[i]} & $\tau \cdot \langle i\rangle$ or \texttt{\_\_getitem\_\_} & Dual resolution \\
Module import & $\mathsf{module}(M, \rho)$ & Singleton with members \\
Protocol & $\mathsf{protocol}(\rho, [], [])$ & Structural satisfaction \\
\hline
\end{tabular}
\caption{Mapping between Python constructs and their type system representations}
\end{table*}
