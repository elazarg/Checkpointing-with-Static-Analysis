\section{Type System}
\label{appendix:typesystem}
\section*{Appendix: Type System Formalization}

This appendix specifies the type system implemented in \texttt{type\_system.py}.  
It is designed to support precise static modeling of scientific Python code (e.g.\ NumPy, SciPy) while avoiding complexity unnecessary for the code bases we target.  
Notably, the system does \emph{not} implement nominal subtyping between user classes, even though class hierarchies are recorded. This is intentional: nominal subtyping in Python is subtle, and was not needed for our analyses.

\subsection{Syntax}

Type expressions $\mathcal{T}$ cover constants, variables (ordinary and variadic), unions, records, classes, modules, polymorphic functions, overloads, instantiations, and literal values.  
Record types $R$ map field keys $f$ to types, where keys can carry both positional and nominal components.  
Effects $\epsilon$ annotate callable types with allocation, mutation, and property metadata.

\begin{figure}[t]
\centering
\[
\begin{aligned}
\tau ::= \;& c \mid X \mid X^* \mid \ell \mid \tau_1 + \tau_2 \mid R \mid f : \tau \\
&\mid \mathsf{class}(C, R, \overline{\tau}, \overline{X}, \mathsf{protocol}?) \\
&\mid \mathsf{module}(M) \\
&\mid \forall \overline{X}.R \xrightarrow{\epsilon} \tau \mid \{\varphi_1, \ldots, \varphi_n\} \\
&\mid \tau\langle\overline{\tau}\rangle
\end{aligned}
\]
\[
R ::= \{f_1 : \tau_1, \ldots, f_n : \tau_n\}
\quad\quad
f ::= \langle i \rangle \mid \langle s \rangle \mid \langle i, s \rangle
\]
\[
\epsilon = (\mathsf{new} : \mathbb{B},\; \mathsf{method} : \mathbb{B},\; \mathsf{update} : \tau^?,\; \mathsf{pointsToArgs} : \mathbb{B})
\]
\caption{Syntax of types, records, field keys, and effects. $c$ ranges over qualified constants; $\ell$ over literal types; $X^*$ denotes variadic type variables.}
\label{fig:syntax}
\end{figure}

\subsection{Type parametricity}
\label{appendix:type-parametricity}

\paragraph{Scope and relation to static semantics.}
This section refines the function application typing judgment from \S\ref{sec:static-semantics}, giving the operational binding procedure that instantiates type parameters, handles partial application, variadic packs, overload resolution, and receiver binding.
. Member lookup, protocol constraints, and attribute-resolution are treated
elsewhere; here we assume the relevant function or method case is already selected.

\paragraph{Notation.}
\begin{itemize}
  \item $\mathrm{dom}(R)$: the set of indices/keys in a row type $R$.
  \item $\theta$: a finite substitution mapping type variables (including packs) to types.
        Application is written $\tau[\theta]$ and is capture-avoiding.
  \item $X^*$: a \emph{pack} type variable. $\mathsf{Star}(\overline{\tau})$ denotes a concrete pack.
  \item $R[a \mapsto \tau]$: row update; $R \setminus S$: row subtraction (remove fields $S$).
  \item $\sqcup$: pointwise join for compatible substitutions (defined below).
\end{itemize}

\paragraph{Substitution join.}
Given substitutions $\theta_1,\ldots,\theta_n$, define
$\bigsqcup_i \theta_i$ iff for every variable $Z$ appearing in more than one $\theta_i$,
the right-hand sides are equal (modulo $\alpha$-conversion). The result maps each $Z$
to that unique right-hand side, and is undefined otherwise.

\paragraph{Callable-emptiness.}
\[
\mathsf{callable\_empty}(R) \;\triangleq\; \mathrm{dom}(R)=\emptyset \;\;\lor\;\;
\bigl(R=\{0:X^*\}\bigr)
\]

\paragraph{Reindexing (positional rows).}
Let $S \subseteq \mathbb{N}$ be the set of matched positional indices in $R$.
Then $\mathsf{subtract\_indices}(R,S)$ shifts each remaining positional index $i\notin S$
down by $|\{j\in S \mid j<i\}|$; keyword fields are unchanged.

\paragraph{Row/argument unification.}
Let $R$ be a parameter row and $A$ an argument row. The unification of a row $R$ with an argument list $A$ is defined in terms of the \emph{binary type unification} relation $\mathsf{unify\_type}$ from Fig.~\ref{fig:unification}, extended pointwise to matching keys:
\[
\mathsf{unify\_row}(R_1, R_2) \;=\; \{ \; k \mapsto \mathsf{unify\_type}(R_1(k), R_2(k)) \;\mid\; k \in \mathrm{dom}(R_1) \cap \mathrm{dom}(R_2) \; \}.
\]
Keys that do not match are handled by the variadic and default-parameter rules described in this section.
Row unification reduces to
field-wise unification:
\[
\frac{
  \forall f \in \mathrm{dom}(R)\cap\mathrm{dom}(A).~ \theta_f = \mathsf{unify}_{\text{type}}\bigl(R[f],A[f]\bigr)
}{
  \mathsf{unify}(R,A) \;=\; \bigsqcup_{f} \theta_f
}
\]
Undefined if any $\theta_f$ is undefined or if the join is undefined.
Here $\mathsf{unify}_{\text{type}}$ is the binary type unification from Fig.~\ref{fig:unification}.

\paragraph{Effects under binding.}
Given a substitution $\theta$ produced by binding (below), effects transform by
(i) substitution: $\epsilon' = \epsilon[\theta]$; and (ii) projection to the residual
parameter set (drop effect components attached to removed parameters). If effects do
not mention parameters, $\epsilon'=\epsilon[\theta]$.

\paragraph{Non-generic functions.}
A non-quantified function case has type $R \xrightarrow{\epsilon} \tau_r$.
Given actual arguments $A$:
\[
\theta = \mathsf{unify}(R,A)
\]
If undefined, the call is ill-typed. Otherwise,
let $S=\mathrm{dom}(R)\cap\mathrm{dom}(A)$. The \emph{residual} is
\[
R_{\mathrm{res}} \;=\; \mathsf{subtract\_indices}\bigl(R\setminus S,\, S\bigr),\quad
\epsilon'=\epsilon[\theta]\text{ (projected)},\quad
\tau_r'=\tau_r[\theta].
\]
If $\mathsf{callable\_empty}(R_{\mathrm{res}})$, the application yields $\tau_r'$;
otherwise the result is the residual function $R_{\mathrm{res}} \xrightarrow{\epsilon'} \tau_r'$.

\paragraph{Quantified functions.}
A quantified case has type $\forall\overline{X}.~R \xrightarrow{\epsilon} \tau_r$.
Binding proceeds as above to produce $\theta$, $R_{\mathrm{res}}$, $\epsilon'$, $\tau_r'$,
and then \emph{drops} any $X\in\overline{X}$ such that $X\not\in \mathrm{FV}(R_{\mathrm{res}})\cup \mathrm{FV}(\tau_r')$,
except pack variables still present in $R_{\mathrm{res}}$.
The residual is $\forall\overline{X}_{\mathrm{res}}.~R_{\mathrm{res}} \xrightarrow{\epsilon'} \tau_r'$,
where $\overline{X}_{\mathrm{res}}$ preserves ordering from $\overline{X}$.

\paragraph{Partial application.}
If only a subset $S \subseteq \mathrm{dom}(R)$ of parameters is matched,
binding applies $\mathsf{unify}$ to $S$, substitutes into all types and effects,
removes $S$ from $R$ via $\mathsf{subtract\_indices}$, and drops solved variables as above.
Residual callables can be applied again.

\paragraph{Variadic packs.}
If $R$ contains exactly one positional row $i:X^*$, after matching all fixed rows:
\begin{enumerate}
    \item \textbf{Binding:} Let $T$ be the set of remaining positional indices (must be contiguous; otherwise undefined).
          Let the corresponding actual element types, ordered by index, be $\overline{\sigma}$.
          Bind $X^* \mapsto \mathsf{Star}(\overline{\sigma})$; if $T=\emptyset$, bind $X^* \mapsto \mathsf{Star}()$.
    \item \textbf{Residual:} Treat the variadic row as matched for substitution purposes,
          but keep it in $R_{\mathrm{res}}$ (shifted to account for earlier removals) so that
          future applications may supply additional positionals.
\end{enumerate}
A case with only a trailing $X^*$ is callable-empty.

\paragraph{Example (variadic pack with partial application).}
Let $f$ have type:
\[
\forall X^*. \ (\star X^*) \xrightarrow{\epsilon} \mathsf{tuple}[X^*]
\]
A call $f(1, \mathsf{True})$ unifies $X^*$ with $(\mathsf{int}, \mathsf{bool})$ and produces the result type $\mathsf{tuple}[\mathsf{int}, \mathsf{bool}]$.

A partial application $f(1)$ unifies $X^*$ with $(\mathsf{int}, Y^*)$, producing the residual callable:
\[
(\star Y^*) \xrightarrow{\epsilon} \mathsf{tuple}[\mathsf{int}, Y^*]
\]
which may be called again with any remaining arguments.

\paragraph{Overloads.}
An overload is a finite set of cases $\{ \varphi_1,\dots,\varphi_m \}$.
For given $A$, attempt binding on each arm independently, obtaining
either failure or a pair $(S_j,\varphi'_j)$ where $S_j$ is the set of matched parameter
rows in arm $j$ (field identifiers: indices for positionals, names for keywords) and $\varphi'_j$ is the residual case.
Discard failures and \emph{group} residuals by identical $S_j$.
Each group $G$ defines a wrapper
\[
(S) \;\to\; \mathsf{Overloaded}\bigl(\{\varphi'_j \mid (S_j,\varphi'_j)\in G\}\bigr).
\]
For an actual \emph{call} at the current site, extract from the inner overloads
the callable-empty cases and join their return types; otherwise the result is the residual overload.

\paragraph{Receiver binding (methods).}
A method case is a function case whose first row is the receiver:
\[
\forall \overline{X}.~(0:\tau_{\mathit{self}},~R') \xrightarrow{\epsilon} \tau_r.
\]
Given a receiver type $\sigma_{\mathit{recv}}$ (obtained by prior member access),
binding runs the same algorithm with $A=\{0:\sigma_{\mathit{recv}}\}$, producing
$\theta$ from $\mathsf{unify}(\{0:\tau_{\mathit{self}}\},\{0:\sigma_{\mathit{recv}}\})$,
dropping the receiver row, reindexing $R'$, substituting $\theta$ in $R',\tau_r,\epsilon$,
and pruning solved type variables as above. The result is a callable over the explicit
parameters after \texttt{self}. Mechanically, this is equivalent to partial application
on the first parameter, with the argument supplied by the receiver.

\paragraph{Arity discipline.}
Unmatched \emph{arguments} are ill-typed; unmatched \emph{parameters} produce residuals.

\paragraph{Worked example.}
Let $\varphi = \forall T,U.~(0:T,\;1:U) \xrightarrow{\epsilon} T$.
\begin{enumerate}
  \item First application with $A=\{0:\mathsf{int}\}$:
  \[
    \theta=\{T\mapsto \mathsf{int}\},\quad S=\{0\},\quad
    R_{\mathrm{res}} = \{0:U\},\quad
    \overline{X}_{\mathrm{res}}=(U)
  \]
  Result: $\forall U.~(0:U)\xrightarrow{\epsilon[\theta]} \mathsf{int}$.
  \item Second application with $A'=\{0:\mathsf{str}\}$:
  \[
    \theta'=\{U\mapsto \mathsf{str}\}
  \]
  Callable-empty $\Rightarrow$ result $\mathsf{int}$.
\end{enumerate}

\paragraph{Remark on class-level parametricity.}
Class-level parametricity, including interaction between class and method type parameters,
is treated separately in \S\ref{sec:rows-generic-access}.


\paragraph{Examples.}  
\begin{itemize}
\item Function \texttt{def f(x: int, y: str = "d")} has type:
 \[\forall \{\}.\{\langle 0, \text{x} \rangle : \mathsf{int}, \langle 1, \text{y} \rangle : \mathsf{str}\} \xrightarrow{\epsilon_\mathsf{pure}} \mathsf{None}\]
\item Generic \texttt{list[int]} is $\mathsf{list}\langle\mathsf{int}\rangle$.
\item Class \texttt{Point} with fields \texttt{x: int, y: int} has record $\{\langle 0, \text{x} \rangle : \mathsf{int}, \langle 1, \text{y} \rangle : \mathsf{int}\}$.
\end{itemize}


\subsection{Rows, TypedDicts, and Generic Access}
\label{sec:rows-generic-access}

\paragraph{Relation to static semantics.}
This section corresponds to the member lookup rules used in \S\ref{sec:static-semantics}, defining how record and class members are retrieved and instantiated prior to the function binding procedure in \S\ref{sec:type-parametricity}.

\paragraph{Scope.}
This subsection defines \emph{rows} (finite maps from keys to types) and their use in typed-dict types, lookup, and class/module member access.
It also specifies the behavior of generic classes and protocols, including instantiation and structural satisfaction, and covers the interaction between class-level type parameters and method-level parameters.
We model \emph{instance members} only; class members would appear as members of the metatype $\mathsf{type}[C]$ and are handled analogously in the metatype section.
All matching is structural; nominal subtyping and base-class hierarchies are not modeled.

\paragraph{Keys and matching.}
Keys range over
\[
k \in \mathcal{K} = \mathbb{N} \,\uplus\, \mathcal{L}
\]
where $\mathbb{N}$ indexes positional fields and $\mathcal{L}$ names labeled fields.
Matching $k \approx k'$ holds iff
\[
(k, k' \in \mathbb{N} \wedge k = k') \quad\lor\quad (k, k' \in \mathcal{L} \wedge k = k')
\]
Keys from different domains never match.

\paragraph{Rows and typed-dicts.}
A \emph{row} is a finite mapping from keys to types:
\[
\rho ::= \{ k_1 : \tau_1, \dots, k_n : \tau_n \}
\]
with the uniqueness invariant $\forall i \neq j.\ k_i \neq k_j$.
We write:
\begin{itemize}
\item $\mathrm{dom}(\rho) = \{ k_1,\dots,k_n \}$
\item $\rho \cdot k = \tau$ if $k:\tau \in \rho$
\item $\rho \setminus S$ for the row with fields whose keys are not in $S$
\end{itemize}

\paragraph{Lattice structure.}
Rows form a lattice $(\mathcal{R}, \sqsubseteq, \sqcup, \sqcap, \top, \bot)$ under an \emph{information ordering}: a row with more fields is more specific (lower in the lattice).
\begin{itemize}
  \item $\top$ = empty row (no constraints)
  \item $\bot$ = inconsistent row (no possible values)
  \item \textbf{Join} ($\sqcup$, least upper bound): pointwise join on keys in the \emph{intersection} of domains
  \item \textbf{Meet} ($\sqcap$, greatest lower bound): pointwise meet on keys in the \emph{union} of domains
\end{itemize}
This ordering differs from the usual set inclusion intuition: because fields have negative polarity --- more fields impose more constraints, meet collects all keys, while join keeps only those common to both.

\paragraph{Lookup.}
Lookup extracts the type(s) associated with a given key from a row or type:
\begin{align*}
\rho \cdot a &= \bigsqcup \{ \tau \mid k:\tau \in \rho \ \wedge\ k \approx a \}
  &&\text{(basic case; $\bot$ if no match)}\\
(\tau_1 + \tau_2) \cdot a &= (\tau_1 \cdot a) \ \sqcup\ (\tau_2 \cdot a)
  &&\text{(union types)} \\
\text{If result is }\{\rho_j \to \tau_j\} &: \quad \bigoplus_j (\rho_j \to \tau_j)
  &&\text{(overloads)}\\
\text{If }\epsilon.\mathsf{property} = \mathsf{true} &: \quad \mathsf{get\_property}(\tau \cdot a) = \sigma
  &&\text{(properties)}
\end{align*}

\paragraph{Generic classes.}
A generic class type has the form
\[
\mathsf{class}\; C[\overline{\alpha}] : \rho
\]
where $\overline{\alpha} = (\alpha_1,\dots,\alpha_m)$ are class-level type parameters, and $\rho$ is the row of member names to their types.

\emph{Instantiation:} Given $\overline{\tau}$ with $|\overline{\tau}| = m$,
\[
C[\overline{\tau}] = (\mathsf{class}\;C[\overline{\alpha}] : \rho)[\alpha_i \mapsto \tau_i]_{i=1}^m
\]
Substitution applies to members, including effects:
\[
(\rho \xrightarrow{\epsilon} \tau)[\alpha \mapsto \sigma] \;=\; (\rho[\alpha \mapsto \sigma]) \xrightarrow{\epsilon[\alpha \mapsto \sigma]} (\tau[\alpha \mapsto \sigma])
\]
Class parameters are in scope for all members.

\paragraph{Method parameter shadowing.}
If a method is quantified $\forall\overline{\beta}.\rho \xrightarrow{\epsilon} \tau$ and $\overline{\beta} \cap \overline{\alpha} \neq \varnothing$, then each $\beta_i$ shadows the corresponding $\alpha_j$ within the method’s scope. No automatic renaming occurs.

\paragraph{Protocols.}
A protocol $\Pi[\overline{\alpha}]: \rho$ is a structural interface.
A type $T$ satisfies $\Pi[\overline{\sigma}]$ iff:
\begin{enumerate}
\item For all $a \in \mathrm{dom}(\rho_{\Pi[\overline{\sigma}]})$, $T \cdot a \neq \bot$.
\item $T \cdot a \ \mathrel{\texttt{unifies}} \ \rho_{\Pi[\overline{\sigma}]} \cdot a$,
  where $\texttt{unifies}$ is the bidirectional unification from the parametricity section.
\end{enumerate}

\paragraph{Member access.}
The member lookup judgment
\[
\tau \ \cdot\ a \ \Downarrow\ v
\]
is defined by:
\begin{align*}
(\mathsf{class}\;C[\overline{\alpha}] : \rho) \cdot a &= \rho \cdot a \\
C[\overline{\tau}] \cdot a &= (\mathsf{class}\;C[\overline{\alpha}]:\rho)[\alpha_i\mapsto\tau_i] \cdot a \\
\mathsf{module}(\rho) \cdot a &= \rho \cdot a \\
(\tau_1 + \tau_2) \cdot a &= (\tau_1 \cdot a) \sqcup (\tau_2 \cdot a)
\end{align*}
If $\rho \cdot a = \bot$, then $\tau \cdot a = \bot$.

\emph{Interaction with parametricity:} If $\tau \cdot a$ is callable, apply receiver binding from \S\ref{sec:type-parametricity}, treating the receiver as the first positional argument.

\paragraph{Worked example.}
\[
\begin{aligned}
&\text{Definition:} \quad \mathsf{class}\; \mathsf{List}[T] :
\{\mathrm{"append"} : (\mathrm{self}:\mathsf{List}[T], x:T) \xrightarrow{\epsilon} \mathsf{None} \} \\[0.5em]
&\text{Instantiation:} \quad \mathsf{List}[\mathsf{int}] =
\{\mathrm{"append"} : (\mathrm{self}:\mathsf{List}[\mathsf{int}], x:\mathsf{int}) \xrightarrow{\epsilon} \mathsf{None} \} \\[0.5em]
&\text{Lookup:} \quad \mathsf{List}[\mathsf{int}] \cdot \mathrm{"append"} =
(\mathrm{self}:\mathsf{List}[\mathsf{int}], x:\mathsf{int}) \xrightarrow{\epsilon} \mathsf{None} \\[0.5em]
&\text{Bind self:} \quad (x:\mathsf{int}) \xrightarrow{\epsilon} \mathsf{None}
\end{aligned}
\]

\subsection{Static Semantics}

\paragraph{Type Environment.}  
$\Gamma$ maps names to types, and $\Delta$ maps type variables to bounds.

\paragraph{Subtyping.}  
Subtyping supports reflexivity and transitivity, union decomposition, record width/depth subtyping and structural subtyping for protocol classes.

There is \emph{no} nominal subtyping rule between arbitrary classes; two distinct non‐protocol classes are unrelated unless one is a union containing the other.

\begin{figure*}[t]
\centering
\[
\frac{}{\Gamma \vdash \tau <: \tau} \quad \text{(Refl)}
\qquad
\frac{\Gamma \vdash \tau_1 <: \tau_2 \quad \Gamma \vdash \tau_2 <: \tau_3}{\Gamma \vdash \tau_1 <: \tau_3} \quad \text{(Trans)}
\]
\[
\frac{\forall i. \Gamma \vdash \tau_i <: \tau}{\Gamma \vdash (\tau_1 + \cdots + \tau_n) <: \tau} \quad \text{(Union-Sub)}
\]
\[
\frac{\mathsf{dom}(R_2) \subseteq \mathsf{dom}(R_1) \quad \forall f \in \mathsf{dom}(R_2).\ \Gamma \vdash R_1(f) <: R_2(f)}{\Gamma \vdash R_1 <: R_2} \quad \text{(Record-Sub)}
\]
\[
\frac{\mathsf{protocol} = \mathsf{true} \quad \Gamma \vdash R_1 <: R_2}{\Gamma \vdash \mathsf{class}(C_1, R_1, \ldots, \mathsf{true}) <: \mathsf{class}(C_2, R_2, \ldots)} \quad \text{(Protocol)}
\]
\caption{Implemented subtyping rules.}
\label{fig:subtyping}
\end{figure*}

\paragraph{Type Operations.}  
Joins $\sqcup$ compute least upper bounds; meets $\sqcap$ compute greatest lower bounds.  
For records:  
\[
R_1 \sqcup R_2 = \{f : R_1(f) \sqcup R_2(f) \mid f \in \mathsf{dom}(R_1) \cap \mathsf{dom}(R_2)\}
\]
\[
R_1 \sqcap R_2 = \{f : R_1(f) \sqcap R_2(f) \mid f \in \mathsf{dom}(R_1) \cup \mathsf{dom}(R_2)\}
\]

Otherwise it is a straightforward union:
\[
\tau \sqcup \tau = \tau
\quad\quad
\tau_1 \sqcup \tau_2 = \tau_1 + \tau_2 \ \text{if unrelated}
\]

\paragraph{Quantified function application.}
When a function expression has type $\forall\overline{X}.~R \xrightarrow{\epsilon} \tau_r$,
its application to an argument list is checked by \emph{binding} the arguments to the
parameters, instantiating $\overline{X}$ as needed, and producing either a result type
or a residual callable. The binding algorithm, including partial application,
variadic packs, overloads, and receiver binding, is defined in
Appendix~\ref{appendix:type-parametricity}.

\paragraph{Unification.}  
Unification $\Delta \vdash \tau_1 \doteq \tau_2 \leadsto \theta$ computes substitutions $\theta : \mathcal{V} \to \mathcal{T}$, supports variadic parameters, instantiation, functions, and records.  
For functions, unification \emph{requires} side effects to be equal; they are not joined at this stage.

\begin{figure*}[t]
\centering
\[
\frac{X \notin \mathsf{dom}(\theta) \quad X \notin \mathsf{FV}(\tau)}{\Delta \vdash X \doteq \tau \leadsto \theta[X \mapsto \tau]} \quad \text{(Var-L)}
\]
\[
\frac{\Delta \vdash \overline{\tau_1} \doteq \overline{\tau_2} \leadsto \theta}{\Delta \vdash c\langle\overline{\tau_1}\rangle \doteq c\langle\overline{\tau_2}\rangle \leadsto \theta} \quad \text{(Inst)}
\]
\[
\frac{X \notin \mathsf{dom}(\theta) \quad \Delta \vdash \overline{\tau_1} \doteq \overline{\tau_2} \leadsto \theta'}{\Delta \vdash X\langle\overline{\tau_1}\rangle \doteq c\langle\overline{\tau_2}\rangle \leadsto \theta[X \mapsto c] \cup \theta'} \quad \text{(Inst-Var)}
\]
\[
\frac{X^* \notin \mathsf{dom}(\theta) \quad X^* \notin \mathsf{FV}(\tau_1, \ldots, \tau_n)}{\Delta \vdash X^* \doteq (\tau_1, \ldots, \tau_n) \leadsto \theta[X^* \mapsto (\tau_1, \ldots, \tau_n)]} \quad \text{(Var-Star)}
\]
\[
\frac{\Delta \vdash R_1 \doteq R_2 \leadsto \theta_1 \quad \Delta \vdash \tau_1 \doteq \tau_2 \leadsto \theta_2 \quad \epsilon_1 = \epsilon_2}{\Delta \vdash (R_1 \xrightarrow{\epsilon_1} \tau_1) \doteq (R_2 \xrightarrow{\epsilon_2} \tau_2) \leadsto \theta_1 \cup \theta_2} \quad \text{(Fun)}
\]
\[
\frac{\forall f_i \in \mathsf{common}(R_1, R_2).\ \Delta \vdash R_1(f_i) \doteq R_2(f_i) \leadsto \theta_i}{\Delta \vdash R_1 \doteq R_2 \leadsto \bigcup_i \theta_i} \quad \text{(Record)}
\]
\caption{Unification rules (function unification requires equal effects).}
\label{fig:unification}
\end{figure*}

\noindent\textbf{Note:} We require $\epsilon_1 = \epsilon_2$ for function unification to succeed, matching the implementation’s strict effect discipline. This choice ensures precision in checkpointing analysis. In other systems, a join or subeffect relation could be used here.

\paragraph{Name Resolution.}  
Name resolution proceeds by current function (we only analyze standalone functions, so class-scope is irrelevant), then module‐local entries in the global module map $\mathcal{M}$, then builtins; otherwise it fails.

\subsection{Dynamic Semantics}

Dynamic semantics covers overload resolution, attribute/index access, and effect composition.

\paragraph{Overload Resolution.}  
Overloads are resolved by unifying parameters against argument types; all matching alternatives’ return types are joined.

\paragraph{Attribute and Index Access.}  
There is no dedicated $\tau.\ell$ syntax form; attribute/index access is an \emph{operation} performed by the interpreter:  
\begin{itemize}
\item If $\tau$ has a matching field in its record or class members, that type is returned.
\item Otherwise, if it has a \texttt{\_\_getitem\_\_} method, that method is applied to the index type.
\end{itemize}

\paragraph{Effects.}  
Effects join pointwise: $\epsilon_1 \sqcup_{\mathcal{E}} \epsilon_2$ 
takes the disjunction of each Boolean component and the optional join $\sqcup^?$ of their \texttt{update} types, where
\[
\tau_1^? \sqcup^? \tau_2^? =
\begin{cases}
\tau_1 \sqcup \tau_2 & \text{if both defined} \\
\tau_i & \text{if only } \tau_i \text{ defined} \\
\bot & \text{if neither defined}
\end{cases}
\]
The `property` concept is separate from effects: properties are modeled as functions with a dedicated \texttt{property} flag.

\begin{figure*}[t]
\centering
\textbf{Overload resolution:}
\[
\mathsf{resolve}(\{\varphi_1, \ldots, \varphi_n\}, \overline{\tau}) =
\bigsqcup\{\mathsf{return}(\varphi_i) \mid \mathsf{unify}(\mathsf{params}(\varphi_i), \overline{\tau}) \ \text{succeeds}\}
\]
\caption{Dynamic semantics: overload resolution (attribute/index access is operational).}
\label{fig:dynamic}
\end{figure*}

\paragraph{Integration with Analysis.}  
The type system supports:
\begin{itemize}
\item Heap shape modeling via record types $R$
\item Effect‐guided mutation and aliasing reasoning
\item Attribute and index resolution during abstract interpretation
\item Allocation site identification from $\epsilon.\mathsf{new}$
\item Row polymorphism for precise parameter passing semantics
\end{itemize}
