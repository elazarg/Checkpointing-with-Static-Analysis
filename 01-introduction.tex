\section{Introduction}
Python powers much of modern numerical computing through libraries like NumPy. The language’s dynamic features, such as dynamic typing, reflection, and flexible control flow, make static analysis notoriously difficult. Yet many Python programs deliberately avoid these constructs, favoring typed, deterministic code and stable libraries. For such well-structured code, we show that established static analysis techniques can be usefully adapted to specific domains of interest. We focus on one important problem domain: efficient checkpointing of long-running programs. 
In this work we demonstrate leveraging static analysis information to perform light-weight instrumentation, reducing storage writes by orders of magnitude compared to existing checkpointing approaches.

Checkpointing is the task of capturing the program’s state at designated points to enable recovery of work done after failure. Unexpected faults in long-running or resource-intensive computations can lead to costly recomputation and lost work. Traditional checkpointing is typically implemented at the system level, treating applications as black boxes. Tools, such as CRIU~\cite{CRIUProject}, snapshot the entire Linux process, including memory, file descriptors, and registers. Virtual machine snapshots~\cite{VMwareSnapshot, RedHatVMSnapshot} go further, capturing entire guest operating system state. While robust and language-agnostic, this approach is usually highly inefficient as it demands large amounts of data be written to storage --- even when done incrementally.

Application-level checkpointing offers an alternative: preserving only the program state that influences future computation. A naive approach might be capturing all reachable state from within the scope of the current program location. Capturing all reachable state is overly conservative. Much of the state is immutable or transient and not needed after resumption.  This naive approach might result in even worse performance than checkpointing the entire process incrementally.

A more sophisticated approach is to look for the specific parts of program state that are both mutated and required for resumption of the computation. This idea dates back decades~\cite{li1990catch} and has recently resurfaced~\cite{kim2024lact}. However, it has seen virtually no adoption in dynamic languages such as Python. The difficulty lies in the language’s dynamic semantics --- runtime typing, reflection, closures --- that make sound static analysis difficult.

That said, many numerical Python workloads already operate within a restricted, well-structured subset of the language. They avoid reflection, rely on type annotations, follow predictable control flow, and depend on stable libraries with well-understood semantics. While these practices limit some of Python’s flexibility, they are common in scientific computing, where correctness and performance outweigh dynamic features. Use of this subset of language features defines the class of programs our static analysis targets.

Our framework combines liveness, pointer, and type analyses with lightweight effect annotations. These annotations classify operations in built-in types and external libraries as allocating, mutating, or pure, enabling analysis of third-party code while maintaining useful precision in heap-shape tracking. In contrast to traditional ``defensive'' analyses, we adopt a \emph{happy-path} approach: assuming the program is correct and inputs are valid, in order to focus precision on the intended execution path.

Building on this framework, we introduce an analysis that identifies the \emph{minimal persistent state}—the subset of program state that must be carried across iterations to ensure correct recovery. This analysis tracks heap shape over loop iterations, determines dirty state via pointer reachability, and restricts results to live variables. From this information we synthesize selective checkpointing logic that preserves only the semantically necessary state.

We evaluate the approach on realistic implementations of numerical algorithms: k-means clustering, orthogonal matching pursuit (OMP), and graph search procedures. These case studies confirm that static analysis techniques, carefully applied to structurally disciplined Python code, can yield major practical benefits.


\paragraph{Contributions}
\begin{enumerate}
\item A reusable static analysis framework for well-typed, structured Python code satisfying certain structural assumptions.
\item Specialized analysis and synthesis steps for checkpoint IO minimization via minimal persistent state analysis.
\item An empirical demonstration showing that semantically guided checkpointing is feasible and highly effective in practical, albeit constrained, Python workloads.
\end{enumerate}

The remainder of the paper is organized as follows. In \autoref{sec:running-example} we present a running example based on the K-Means clustering algorithm to illustrate the challenges and opportunities for selective checkpointing in numerical Python code. \autoref{sec:analysis} describes our analysis framework in detail, including the intermediate representation, the design of the type and pointer domains, and the interaction between liveness, type, and heap analyses. \autoref{sec:evaluation} evaluates our approach on several realistic workloads, comparing our synthesized checkpoints against naive and system-level baselines. \autoref{sec:related} discusses related work in static analysis for dynamic languages and checkpointing. We conclude in \autoref{sec:conclusion} with a summary of our contributions and directions for future work.
