\section{Introduction}
Python powers much of modern numerical computing through libraries like NumPy. The language’s dynamic features, such as dynamic typing, reflection, and flexible control flow, make static analysis notoriously difficult. Yet many Python programs deliberately avoid these constructs, favoring typed, deterministic code and stable libraries. For such well-structured code, we show that established static analysis techniques can be adapted to automatically synthesize selective checkpointing logic, reducing snapshot sizes by 2–5 orders of magnitude in our case studies compared to system-level or naive approaches.

We explore this by applying conventional program analyses to numerical Python code that satisfies common structural constraints: no reflection, statically typed inputs, and predictable control flow. These constraints, common in numerical workloads, are essential to enabling precise static reasoning. We use a combination of liveness, pointer, and type analyses, augmented with simple effect annotations. The annotations classify operations across built-in types and external libraries as allocating, mutating, or pure. This enables the use of third-party libraries while maintaining nontrivial precision in heap-shape tracking.

To demonstrate the utility of these analyses, we target a concrete optimization problem common in long-running numerical workloads: \emph{minimizing checkpoint overhead}. Iterative programs often require periodic checkpoints to guard against failure, but naively saving the entire program state at each checkpoint introduces significant overhead, especially when much of that state is transient or unused across iterations.

To reduce checkpoint overhead, we develop an analysis that identifies the \emph{minimal persistent state}, the subset of program state that must survive from one iteration to the next to ensure correct execution after recovery. This analysis performs heap shape tracking across loop iterations, determining dirty state via pointer reachability, constrained to live variables. The result is automatic synthesis of selective checkpointing logic that preserves only semantically meaningful state.

We evaluate the synthesis on realistic implementations of numerical algorithms: k-means clustering, orthogonal matching pursuit (OMP), and graph search procedures. These case studies confirm that static analysis techniques, carefully applied to structurally disciplined Python code, can yield major practical benefits.

\paragraph{Contributions}
\begin{enumerate}
\item A reusable static analysis framework for well-typed, structured Python programs satisfying our target constraints.
\item Specialized analysis and synthesis steps for iteration-aware checkpoint minimization via escape analysis.
\item An empirical demonstration that semantically guided checkpointing is feasible and highly effective in practical, albeit constrained, Python workloads.
\end{enumerate}

The remainder of the paper is organized as follows. In \autoref{sec:running-example} we present a running example based on the K-Means clustering algorithm to illustrate the challenges and opportunities for selective checkpointing in numerical Python code. \autoref{sec:analysis} describes our analysis framework in detail, including the intermediate representation, the design of the type and pointer domains, and the interaction between liveness, type, and heap analyses. \autoref{sec:evaluation} evaluates our approach on several realistic workloads, comparing our synthesized checkpoints against naive and system-level baselines. \autoref{sec:related} discusses related work in static analysis for dynamic languages and checkpointing. We conclude in \autoref{sec:conclusion} with a summary of contributions and directions for future work.
