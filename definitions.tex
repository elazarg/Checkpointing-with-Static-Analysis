\newcommand{\Id}[0]{\textbf{Id}}
\newcommand{\Location}[0]{\textbf{Location}}
\newcommand{\Type}[0]{\textbf{Type}}
\newcommand{\Addr}[0]{\textbf{Addr}}
\newcommand{\Locals}[0]{\textbf{Locals}}
\newcommand{\Globals}[0]{\textbf{Globals}}
\newcommand{\ObjN}[0]{\textbf{ObjN}}
\newcommand{\ObjS}[0]{\textbf{ObjS}}
\renewcommand*{\H}[0]{\mathcal{H}}
\newcommand*{\T}[0]{\mathcal{T}}
\newcommand{\D}[0]{\mathcal{D}}

\begin{figure*}
\begin{align}
\Addr^{\#} \stackrel{\text{def}}{=}& \Location \cup \{ \Locals, \Globals \} \\
\H^{\#} \stackrel{\text{def}}{=}& \Addr^{\#} \rightharpoonup (string \rightharpoonup \mathcal{P}(\Location)) \\
\T^{\#} \stackrel{\text{def}}{=}& \Location \rightharpoonup \Type
\end{align}

\begin{align}
\ObjN^{\#} \stackrel{\text{def}}{=}& string^{+} \\
\ObjS^{\#} \stackrel{\text{def}}{=}& \{\top\} \cup 
          \big(\mathcal{P}(string) \times (string \rightharpoonup \Addr^{\#})\big)
\end{align}

\begin{align}
&\gamma_{\ObjN}[\alpha_{\Addr}](AInt(@^{\#})) = \{ int(@, i) \, | \, i \in \mathbb{Z}, \alpha_{\Addr}(@) = @^{\#} \} \\
&\gamma_{\ObjN}[\alpha_{\Addr}](AStr(@^{\#})) = \{ string(@, s) \, | \, s \in \mathcal{P}(str), \alpha_{\Addr}(@) = @^{\#} \} \\
&\gamma_{\ObjN}[\alpha_{\Addr}](AMethod(@^{\#}, f)) = \{ Method(@, f) \, | \, \alpha_{\Addr}(@) = @^{\#} \} \\
&\gamma_{\ObjN}[\alpha_{\Addr}](AClass(c)) = \{ Class(c) \} \\
&\gamma_{\ObjN}[\alpha_{\Addr}](AFun(f)) = \{ Fun(f) \} \\
&\gamma_{\ObjN}[\alpha_{\Addr}](AInst(@^{\#})) = \{ Instance(@) \, | \, \alpha_{\Addr}(@) = @^{\#} \}
\end{align}

\begin{align}
&\gamma_{\ObjS}[\alpha_{\Addr}](\mu \in \mathcal{P}(string), f^{\#} \in string \rightharpoonup \Addr^{\#}) = \{ & f \in \ObjS = string \rightharpoonup \Addr \, | \,
&        & \mu \subseteq \text{dom}\, f \subseteq \text{dom}\, f^{\#} \\
&        & \wedge \forall s \in \text{dom}\, f, \alpha_{\Addr}(f(s)) = f^{\#}(s) \} \\
& \gamma_{\ObjS}[\alpha_{\Addr}](\top) = \ObjS 
\end{align}

\begin{align}
\gamma_\H[\alpha_{\Addr}](\eta \in \H^{\#}) =& \{ h \in \H \, | \, \forall@ \in \text{dom}\, \alpha_{\Addr},  h(@) = (n, s) \\
& \wedge \big( \exists(n^{\#}, s^{\#}) \in \eta(\alpha_{\Addr}(@)), n \in \gamma_{\ObjN}[\alpha_{\Addr}](n^{\#}) \wedge s \in \gamma_{\ObjS}[\alpha_{\Addr}](s^{\#}) \big) \} 
\end{align}

\begin{align}
&\gamma_F[\alpha_{\Addr}](exn\, @^{\#}) = \{ exn\, @ \, | \, \alpha_{\Addr}(@) = @^{\#} \} \\
&\gamma_F[\alpha_{\Addr}](f \in F^{\#}, f \neq exn\,\_) = \{ f \}
\end{align}

\begin{align}
\gamma_\D(\delta \in \D^{\#}) =& \bigcup_{\phi \in \text{dom}\, \delta} \gamma(\phi, \delta(\phi))
\end{align}

\end{figure*}

\begin{figure*}
\begin{align}
\textbf{Type} &\stackrel{\text{def}}{=}
  \textbf{Ref} \cup \textbf{Literal} \cup \textbf{TypeVar} \cup \textbf{Star} \cup \textbf{TypedDict} \cup \textbf{Overloaded} \cup \textbf{Class} \cup \textbf{Module} \cup \textbf{FunctionType} \cup \textbf{Union} \cup \textbf{Instantiation} \cup \textbf{Access} \\
\textbf{Ref} &\stackrel{\text{def}}{=} \textit{named reference} \in \text{string} \\
\textbf{Literal} &\stackrel{\text{def}}{=} v : \textbf{Ref} \quad \text{where } v \in \mathbb{Z} \cup \mathbb{R} \cup \text{string} \cup \cdots \\
\textbf{TypeVar} &\stackrel{\text{def}}{=} \alpha \in \text{string} \quad \text{(optionally starred)} \\
\textbf{Star} &\stackrel{\text{def}}{=} *(\tau_1, \dots, \tau_n) \quad \text{for } \tau_i \in \textbf{Type} \\
\textbf{TypedDict} &\stackrel{\text{def}}{=} \mathbb{N} \times \text{string} \rightharpoonup \textbf{Type} \\
\textbf{Overloaded} &\stackrel{\text{def}}{=} \{f_1, \dots, f_n\}, \quad f_i \in \textbf{FunctionType} \\
\textbf{FunctionType} &\stackrel{\text{def}}{=} (\textbf{TypedDict}, \textbf{Type}, \textbf{SideEffect}) \quad \text{with optional } \vec{\alpha} \in \textbf{TypeVar}^{*} \\
\textbf{Class} &\stackrel{\text{def}}{=} (n, d, \vec{c}, p, \vec{\alpha}) \quad \text{where } 
n \in \text{string},\; d \in \textbf{TypedDict},\; \vec{c} \subseteq \textbf{Type},\; p \in \{\text{true}, \text{false}\} \\
\textbf{Module} &\stackrel{\text{def}}{=} (n, d) \quad \text{where } n \in \text{string},\; d \in \textbf{TypedDict} \\
\textbf{Instantiation} &\stackrel{\text{def}}{=} \tau[\tau_1, \dots, \tau_n] \quad \text{with } \tau, \tau_i \in \textbf{Type} \\
\textbf{Access} &\stackrel{\text{def}}{=} \tau_1[\tau_2] \quad \text{where } \tau_1, \tau_2 \in \textbf{Type}
\end{align}
\begin{align}
\textbf{Notes:} \\
& \bullet\ \text{Types are structural unless explicitly named (\textbf{Ref})} \\
& \bullet\ \text{Function overloading is modeled by finite sets of \textbf{FunctionType}} \\
& \bullet\ \text{Subtyping is derived via least upper bounds (join)} \\
& \bullet\ \text{Function types may carry side effects and generic parameters} \\
& \bullet\ \text{Starred (\textbf{Star}) and variadic type variables enable flexible arity}
\end{align}
\end{figure*}
