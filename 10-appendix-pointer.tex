\section{Pointer and Dirty Domains}
\label{appendix:pointer}

This appendix specifies the abstract domains and transfer functions for the pointer
and dirty components of our analysis.
Together they track heap shape, object types, and mutations since the last checkpoint.
The domains form a reduced product with the type system
(Appendix~\ref{appendix:typesystem}),
and are parameterised by the TAC intermediate representation
(Appendix~\ref{appendix:tac-ir}) and liveness information
(\S\ref{sec:analysis}).

\subsection{Abstract Objects}

\paragraph{Syntax.}
Abstract objects $o \in \mathcal{O}$ are given by:
\[
o ::= \mathsf{Loc}(\ell) \mid \mathsf{Param}(p) \mid \mathsf{Imm}(\tau) \mid \mathsf{Scope}(s).
\]

\noindent
Here:
\begin{itemize}
  \item $\mathsf{Loc}(\ell)$: allocation site at instruction location $\ell$;
  \item $\mathsf{Param}(p)$: distinguished object for function parameter $p$;
  \item $\mathsf{Imm}(\tau)$: immutable constant value of type $\tau$;
  \item $\mathsf{Scope}(s)$: symbolic root object for special scopes
        (e.g.\ \texttt{LOCALS}, \texttt{GLOBALS}).
\end{itemize}

\subsection{Pointer Domain}

\paragraph{Definition.}
The pointer graph is a mapping
\[
P : \mathcal{O} \to (\mathcal{F} \to 2^{\mathcal{O}}),
\]
with default value $\emptyset$ for missing fields.
A field $f \in \mathcal{F}$ is either an attribute name,
a dictionary key, or the wildcard $\star$ for element collections.
Intuitively, $P[o][f]$ is the set of abstract objects that may be
stored in field $f$ of object $o$.

\paragraph{Example.}
If instruction $\ell$ allocates a list of integers,
then
\[
P[\mathsf{Loc}(\ell)][\star] = \{\, \mathsf{Imm}(\texttt{int}) \,\}
\]
represents the listâ€™s element type.

\paragraph{Order and join.}
Pointer states are ordered pointwise by inclusion:
\[
P_1 \sqsubseteq P_2 \;\;\iff\;\;
\forall o,f.\; P_1[o][f] \subseteq P_2[o][f].
\]
Join is defined by union:
\[
(P_1 \sqcup P_2)[o][f] = P_1[o][f] \cup P_2[o][f].
\]
The bottom element maps all fields to $\emptyset$.

\paragraph{Reachability.}
For a root set $R \subseteq \mathcal{O}$,
the set of reachable objects is:
\[
\mathsf{Reach}(R,P) = \mu X.\; R \cup \{\, o' \mid o \in X,\; o' \in P[o][f] \,\}.
\]
Roots are restricted using liveness (\S\ref{sec:analysis})
so that dead variables do not retain their objects.

\subsection{Type Map}

\paragraph{Definition.}
Each object has a type, used for attribute and effect resolution:
\[
T : \mathcal{O} \to \mathit{TypeExpr},
\]
where $\mathit{TypeExpr}$ is the type language of
Appendix~\ref{appendix:typesystem}.
Join and order are lifted pointwise from the type lattice.

\subsection{Dirty Domain}

\paragraph{Definition.}
The dirty domain records which fields have been updated since the last checkpoint:
\[
D : \mathcal{O} \to 2^{\mathcal{F}}.
\]
Here $D[o]$ is the set of fields of object $o$ that may have been written.
The order is subset inclusion, and join is union.

\paragraph{Dirty roots.}
Given a live root set $R$,
the dirty variables are those that reach an object with dirty fields:
\[
\mathsf{DirtyRoots}(\Sigma, R) =
\{\, v \in R \mid \exists o \in P[\mathsf{LOCALS},v].\; D[o] \neq \emptyset \,\}.
\]
Only these roots and their reachable subgraph must be checkpointed.

\subsection{Typed Pointer State}

\paragraph{Definition.}
The combined state is a triple:
\[
\Sigma = (P, T, D).
\]
The order and join are defined componentwise, and the bottom element is
\[
\bot_\Sigma = (\bot_P, \bot_T, \bot_D).
\]

\subsection{Abstract Semantics}

We write
\[
\mathsf{Expr}^\#(\Sigma,e,\ell) = (O,\tau,\Delta)
\]
for evaluation of an expression $e$ at location $\ell$,
yielding a set of possible objects $O$, a type $\tau$,
and a partial dirty map $\Delta : \mathcal{O} \to 2^{\mathcal{F}}$
for additional dirty updates.

\paragraph{Expression evaluation.}
Representative cases are:

\[
\frac{o \in P[\mathsf{LOCALS}][v] \quad \tau = T[o]}
     {\mathsf{Expr}^\#(\Sigma, v, \ell) = (\{o\}, \tau, \bot_D)}
\]

\[
\mathsf{Expr}^\#(\Sigma,\mathsf{Const}(c),\ell) =
(\{\, \mathsf{Imm}(\tau_c) \,\}, \tau_c, \bot_D)
\]

\[
\frac{(O,\tau,\Delta) = \mathsf{Expr}^\#(\Sigma,e,\ell) \quad
      \tau' = \mathsf{Access}(\tau,f)}
     {\mathsf{Expr}^\#(\Sigma, e.f, \ell) =
       (\bigcup_{o \in O} P[o][f], \tau', \Delta)}
\]

\[
\frac{(\tau',\epsilon) = \mathsf{Apply}(\tau_f,\overline{\tau})}
     {\mathsf{Expr}^\#(\Sigma, f(\overline{a}), \ell) =
       (O', \tau', \Delta \sqcup \mathsf{Effects}(\epsilon,O',\ell))}
\]

Other cases (binary, unary, subscripts) follow the same pattern,
using the corresponding type-system operations.

\paragraph{Instruction transfer.}
We define $\mathsf{Trans}^\#(\Sigma, i, \ell)$ for TAC instruction $i$.
Formally:

\[
\frac{(O,\tau,\Delta) = \mathsf{Expr}^\#(\Sigma,e,\ell)}
     {\mathsf{Trans}^\#(\Sigma, x = e, \ell) =
       (P[\mathsf{LOCALS},x \mapsto O],\; T[O \mapsto \tau],\; D \sqcup \Delta)}
\]

\[
\frac{(O,\tau,\Delta) = \mathsf{Expr}^\#(\Sigma,e,\ell) \quad
      O_t = P[\mathsf{LOCALS},o]}
     {\mathsf{Trans}^\#(\Sigma, o.f = e, \ell) =
       (P', T', D')}
\]

\noindent
where for each $t \in O_t$:
\[
P'[t][f] =
\begin{cases}
O & \text{if $t$ is the unique target (strong update)} \\
P[t][f] \cup O & \text{otherwise (weak update).}
\end{cases}
\]

\noindent
Additionally, $T'[o] = T[o] \sqcup \tau$ for $o \in O$,
and $D'[t] = D[t] \cup \{f\}$.

\paragraph{Deletion.}
Deleting a field is modelled as marking it dirty. Formally:
\[
\mathsf{Trans}^\#(\Sigma, \mathsf{Del}(o.f), \ell) =
  (P, T, D[o \mapsto D[o] \cup \{f\}]).
\]

Assignments to subscripts, destructuring tuples, and calls
follow the same pattern but use the type-system operations
$\mathsf{Subscr}$, $\mathsf{Unpack}$, and $\mathsf{Apply}$.

\paragraph{Garbage collection.}
After each instruction, we prune unreachable objects:
\[
\mathsf{GC}(\Sigma, R) =
 (P|_S,\; T|_S,\; D|_S)
\quad\text{where } S = \mathsf{Reach}(R,P).
\]
Here $M|_S$ denotes restriction of map $M$ to keys in $S$,
with fields updated to drop edges targeting objects outside $S$.

\subsection{Soundness Sketch}

The abstraction is designed so that for any concrete TAC semantics
(Appendix~\ref{appendix:tac-ir}),
execution preserves the invariant:
\[
\gamma(\Sigma^\#) \supseteq
\{\, \text{concrete states corresponding to }\Sigma^\# \,\}.
\]
This extends the semantic preservation property of
Appendix~\ref{appendix:tac-ir} by incorporating heap shape,
types, and mutation tracking.
In particular, if a concrete field has been written,
the corresponding abstract field is marked dirty:
dirtyness is a sound over-approximation of concrete mutations.

\paragraph{Assumptions.}
\begin{enumerate}
  \item No reflective operations beyond the modelled subset.
  \item Immutable values remain immutable.
  \item Strong updates are used only when aliasing is ruled out.
  \item Liveness correctly identifies variables that cannot be accessed again.
\end{enumerate}

\paragraph{Remarks.}
Field deletion is treated as a write; object identity is abstracted to allocation sites.
We do not model imports, generators, async/await, or exceptions beyond terminal raises.
Our focus is on intraprocedural, synchronous execution paths.

\paragraph{Implementation note.}
In practice, maps are implemented as hash tables keyed by abstract objects,
with joins computed lazily to scale to large scientific workloads.
