\begin{figure*}[t]
\centering

\begin{minipage}[t]{0.32\textwidth}
\centering
\textbf{Pointer Domain ($P$)}
\begin{gather*}
P \in \mathcal{P} = \mathcal{O} \to (\mathcal{F} \to 2^{\mathcal{O}}) | \bot_\mathcal{P} \\[0.3em]
P_1 \sqsubseteq P_2 \iff \forall o.\; P_1[o] \subseteq P_2[o] \\[0.3em]
(P_1 \sqcup P_2)[o] = P_1[o] \cup P_2[o] \\
\end{gather*}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.32\textwidth}
\centering
\textbf{Type Domain ($T$)}
\begin{gather*}
T \in \mathcal{T} = \mathcal{O} \to \mathit{TypeExpr} | \bot_\mathcal{T} \\[0.3em]
T_1 \sqsubseteq T_2 \iff \forall o.\; T_1[o] \leq: T_2[o] \\[0.3em]
(T_1 \sqcup T_2)[o] = T_1[o] \sqcup T_2[o]
\end{gather*}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.32\textwidth}
\centering
\textbf{Dirty Domain ($D$)}
\begin{gather*}
D \in \mathcal{D} = \mathcal{O} \to 2^{\mathcal{F}} | \bot_\mathcal{D} \\[0.3em]
D_1 \sqsubseteq D_2 \iff \forall o.\; D_1[o] \subseteq D_2[o] \\[0.3em]
(D_1 \sqcup D_2)[o] = D_1[o] \cup D_2[o]
\end{gather*}
\end{minipage}

\vspace{1.5em}

\noindent\textbf{Reduced Product ($\Sigma$)}
\begin{align*}
\Sigma &= (P,T,D) \in \mathcal{P} \times \mathcal{T} \times \mathcal{D} | \bot_\Sigma\\[0.3em]
\Sigma_1 \sqsubseteq \Sigma_2 &\iff P_1 \sqsubseteq P_2 \land T_1 \sqsubseteq T_2 \land D_1 \sqsubseteq D_2 \\[0.3em]
\Sigma_1 \sqcup \Sigma_2 &= (P_1 \sqcup P_2,\; T_1 \sqcup T_2,\; D_1 \sqcup D_2)
\end{align*}

\caption{Abstract domains for heap analysis combining pointer tracking, type information, and mutation tracking.}
\label{fig:abstract-domains}
\end{figure*}

\newpage

\section{Pointer Analysis}
\label{sec:appendix-pointer}

\subsection{Overview and Motivation}

The pointer analysis is a cornerstone of our static analysis framework, designed to support checkpointing optimization in Python programs by modeling the heap and tracking object mutations. Operating on the Three-Address Code (TAC) intermediate representation (\autoref{sec:appendix-tac-ir}) and integrated with the type system (\autoref{sec:appendix-typesystem}), it constructs a precise model of heap shape, object references, and field updates. This enables the identification of minimal live variables and objects requiring checkpointing, critical for efficient state preservation in numerical workloads.

Pythonâ€™s dynamic features such as dynamic typing, reflection, and runtime object modification pose significant challenges for static heap analysis. The pointer analysis addresses these by combining pointer, type, and dirty domains into a reduced product. This synergy enhances precision by leveraging type information for attribute resolution and liveness for pruning unreachable objects. The analysis is flow-sensitive and intraprocedural, focusing on synchronous, exception-free paths to ensure tractability while maintaining soundness within defined assumptions.

\subsection{Notation}

Consistent with \autoref{sec:appendix-tac-ir} and \autoref{sec:appendix-typesystem}, we use:
\begin{itemize}
    \item $\mathcal{V}$: Variables, split into named locals $\mathcal{V}_{\mathit{named}}$ (e.g., $x$) and stack temporaries $\mathcal{V}_{\mathit{stack}}$ (e.g., $\$0$).
    \item $\mathcal{O}$: Abstract objects.
    \item $\mathcal{F}$: Fields, including instance attribute names, dictionary keys, and wildcard $\star$ for collections.
    \item $(l, i)$: Instruction location, where $l \in L$ and $i$ indexes into $B(l)$.
    \item $\mathsf{Live}_{l,i} \subseteq \mathcal{V}$: Live variables at $(l,i)$.
\end{itemize}

\subsection{Abstract Domains}

The pointer analysis models heap behavior through a reduced product $\Sigma = (P, T, D)$, combining pointer, type, and dirty domains to support checkpointing.

\paragraph{Abstract Objects ($\mathcal{O}$).}
Abstract objects represent equivalence classes of concrete heap locations:
\begin{itemize}
    \item $\mathsf{Loc}(\ell,i)$: Objects allocated at instruction $(\ell,i)$, merging all mutable runtime instances allocated there.
    \item $\mathsf{Param}(p)$: Placeholders for function parameters, modeling unknown external inputs.
    \item $\mathsf{Imm}(\tau)$: Immutable objects of type $\tau$ (e.g., any \texttt{int}, $\mathtt{True}$).
    \item $\mathsf{Scope} = \{\mathtt{LOCALS}, \mathtt{GLOBALS}\}$: Distinguished root objects for variable namespaces, whose fields correspond to variables.
\end{itemize}

The domains are described in \autoref{fig:abstract-domains}. $P$ and $D$ are are map-of-sets domains. The pointer domain $P$ models heap shape, where $P[o][f]$ is the set of possible targets of field $f$ of object $o$. The wildcard field $\star$ summarizes collection elements. The type domain $T$ assigns types to objects, with ordering and join operations defined over the type lattice (see \autoref{sec:appendix-typesystem}). The dirty domain $D$ tracks which fields may have been dirty. Bottom elements: $\bot_\mathcal{P}$ maps every $(o,f)$ to $\emptyset$, $\bot_{\mathcal{T}}$ maps each object to $\bot_{\mathit{Type}}$, and $\bot_\mathcal{D}$ maps each object to $\emptyset$. The reduced product $\Sigma$ combines all three domains with component-wise lattice operations. Information flow between the domain occurs only in the abstract transformer.

\subsection{Abstract Semantics}

\paragraph{Expression Evaluation} $\mathsf{Expr}^\#(\Sigma, e, \ell)$ produces a triple:
\[
\mathsf{Expr}^\#(\Sigma, e, \ell) = \big(O_e,\ \tau_e,\ \Delta_e\big)
\]
where:
\begin{itemize}
    \item $O_e \subseteq \mathcal{O}$: objects reachable via $e$,
    \item $\tau_e \in \mathit{TypeExpr}$: inferred static type,
    \item $\Delta_e \in \mathcal{D}$: fields potentially dirtied.
\end{itemize}

Key evaluation rules are shown in \autoref{fig:expr-semantics}. Note that the choice of immutable objects $\mathsf{Imm}$ is guided by the type system; \textsc{Const} is just a special case where it is syntactically forced. 

\begin{figure}[t]
\centering
\begin{mathpar}
\inferrule*[right=Var]
  { o = P[\mathtt{LOCALS}][v] }
  { \mathsf{Expr}^\#((P, D, T), v, \ell) = (\{o\}, T[o], \bot_\mathcal{D}) }

\inferrule*[right=Const]
  { \tau_c = \mathsf{type}(c) }
  { \mathsf{Expr}^\#((P, D, T), c, \ell) = (\{\mathsf{Imm}(\tau_c)\}, \tau_c, \bot_\mathcal{D}) }

\inferrule*[right=Attr]
  { O = P[\mathtt{LOCALS}][v] \\
    O' = \bigcup_{o\in O} P[o][f] \\
    \tau' = \mathsf{Access}(\tau,f) }
  { \mathsf{Expr}^\#(\Sigma, \mathsf{Attribute}(v,f), \ell) = (O',\tau',\Delta) }

\inferrule*[right=Call]
  { O_f = P[\mathtt{LOCALS}][v_f] \\
    O_i = P[\mathtt{LOCALS}][v_i] \quad \forall i=1,\dots,n \\
    (\tau',\epsilon^\#) = \mathsf{Apply}(\tau_f,\langle\overline{\tau_i}\rangle) \\
    O' = \mathsf{resolve}(O_f,\langle\overline{O_i}\rangle,\epsilon^\#) \\
    \Delta = \mathsf{update}(\epsilon^\#) }
  { \mathsf{Expr}^\#(\Sigma,\mathsf{Call}(v_f,\overline{v_i},\mathsf{None}),\ell) = (O',\tau',\Delta) }
\end{mathpar}
\caption{Expression evaluation rules for pointer analysis.}
\label{fig:expr-semantics}
\end{figure}

\paragraph{Instruction Semantics.}
Instruction transfer functions $\mathsf{Trans}^\#(\Sigma,i,\ell) \to \Sigma'$ update the abstract state, as shown in \autoref{fig:trans-semantics}.

\begin{figure*}[t]
\centering
\textbf{Update Definitions:}
\begin{align}
\mathsf{Update}(P, O_{\text{targets}}, \text{field}, O_{\text{new}}) &= P' \text{ where } P'[t][\text{field}] = \begin{cases}
  O_{\text{new}} & \text{if } |O_{\text{targets}}| = 1 \\
  P[t][\text{field}] \cup O_{\text{new}} & \text{otherwise}
\end{cases} \text{ for all } t \in O_{\text{targets}} \\
\mathsf{UpdateSubscr}(P, O_1, O_2, O_{\text{new}}) &= P' \text{ where } P'[t][k] = \begin{cases}
  O_{\text{new}} & \text{if } |O_1| = 1 \\
  P[t][k] \cup O_{\text{new}} & \text{otherwise}
\end{cases} \text{ for all } t \in O_1, k \in O_2
\end{align}
\begin{mathpar}
\inferrule*[right=Assign-Var]
  { \mathsf{Expr}^\#((P, D, T),e,\ell) = (O,\tau,\Delta)}
  { \mathsf{Trans}^\#((P, D, T),\mathsf{Assign}(x,e,\mathsf{false}),\ell) = (P[\mathtt{LOCALS}][x \mapsto O],T[O \mapsto \tau],D \sqcup \Delta) } \\
\inferrule*[right=Assign-Subscr]
  { O_1 = P[\mathtt{LOCALS}][v_1] \quad O_2 = P[\mathtt{LOCALS}][v_2]  \\
    P' = \mathsf{UpdateSubscr}(P, O_1, O_2, P[\mathtt{LOCALS}][v]) \\
    D' = \mathsf{Update}(D, O_1, \text{deps}, O_2) }
  { \mathsf{Trans}^\#((P, D, T), \mathsf{Assign}(\mathsf{Subscript}(v_1, v_2), v, \mathsf{false}), \ell)
    = (P', T, D') } \\
\inferrule*[right=Assign-Attr]
  { O_1 = P[\mathtt{LOCALS}][v_1] \\
    P' = \mathsf{Update}(P, O_1, f, P[\mathtt{LOCALS}][v]) \\
    D' = \mathsf{Update}(D, O_1, \text{deps}, \{f\}) }
  { \mathsf{Trans}^\#((P, D, T),\mathsf{Assign}(\mathsf{Attribute}(v_1,f),v,\mathsf{false}),\ell)
    = (P',T,D') }
\end{mathpar}
\caption{Selected instruction transfer rules for pointer analysis using weak updates.}
\label{fig:trans-semantics}
\end{figure*}


\subsection{Reachability and Garbage Collection}

\begin{itemize}
    \item $\mathsf{Reach}(R, P)$: Reachable objects from roots $R \subseteq \mathcal{O}$ under pointer map $P$.
    \item $\mathsf{DirtyRoots}(\Sigma, R)$: Live roots reaching dirty objects in state $\Sigma$.
\end{itemize}

Reachable objects are computed as the least fixed point:
\[
\mathsf{Reach}(R,P) = \mu X.\; R \cup \{ o' \mid o \in X,\ f \in \mathcal{F},\ o' \in P[o][f] \}
\]
Abstract garbage collection prunes unreachable objects:
\[
\mathsf{GC}(\Sigma,R) = \big( P|_S,\ T|_S,\ D|_S \big),
\quad
S = \mathsf{Reach}(R,P)
\]
where roots $R$ are derived from liveness:
\[
R = \big\{ P[\mathtt{LOCALS}][v] \mid v \in \mathsf{Live}_{l,i} \big\}
\]

\paragraph{Dirty Roots.}
The function $\mathsf{DirtyRoots}(\Sigma,R)$ identifies variables whose reachable sub-heaps have pending mutations:
\begin{align*}
\mathsf{DirtyRoots}(\Sigma,R) = \{ v \in R \mid & \exists o \in \mathsf{Reach}(\{P[\mathtt{LOCALS}][v]\},P) \\
                                                & D[o] \neq \emptyset \}
\end{align*}
This supports efficient checkpointing by focusing only on modified reachable objects.

\subsection{Operational Helpers and Effects}

Pointer analysis integrates tightly with the type system via effectful operations:
\begin{itemize}
    \item $\mathsf{Access}(\tau,f)$: Resolves type of attribute $f$ of type $\tau$.
    \item $\mathsf{Apply}(\tau_f,\langle\overline{\tau_i}\rangle)$: Returns function result type and effect.
    \item $\mathsf{resolve}(O_f,\langle\overline{O_i}\rangle,\epsilon^\#)$: Determines target objects based on effect $\epsilon^\#$.
    \item $\mathsf{update}(\epsilon^\#)$: Extracts dirty fields from $\epsilon^\#$.
\end{itemize}
Effects $\epsilon^\# = (\mathsf{new},\mathsf{update},\mathsf{points\_to\_args},\mathsf{bound\_method})$ guide heap updates and ensure that mutations are precisely tracked.

\subsection{Soundness}

We define a concretization function $\gamma: \Sigma \mapsto 2^{Obj}$ mapping abstract states to sets of possible concrete heaps.  
Soundness requires:
\[
\forall \Sigma^\#,\ \forall H \in \gamma(\Sigma^\#):
    \quad \Sigma^\# \models P[o][f] \supseteq \{ H(o).f \}
\]
That is, the abstract state over-approximates all reachable concrete objects and all field writes:
\begin{itemize}
    \item If a concrete field write occurs, it is reflected in $D[o]$.
    \item $P$ represents all concrete pointer relations.
\end{itemize}
Soundness follows from the monotonicity of $\mathsf{Expr}^\#$ and $\mathsf{Trans}^\#$, and the compatibility of TAC with the reduced product lattice.

\subsection{Example}

Consider:
\begin{lstlisting}[language=python]
x = [1, 2]      # Allocate list at l1
x.append(3)     # Update list
y = x           # Alias
\end{lstlisting}

TAC translation:
\begin{itemize}
    \item $\mathsf{Assign}(x,\mathsf{Call}(\mathtt{list},\langle1,2\rangle,\mathsf{None}),\mathsf{false})$ at $(l_1,0)$.
    \item $\mathsf{Assign}(\mathsf{None},\mathsf{Call}(\mathsf{Attribute}(x,\mathtt{append}),\langle3\rangle,\mathsf{None}),\mathsf{false})$.
    \item $\mathsf{Assign}(y,x,\mathsf{false})$.
\end{itemize}

Pointer analysis yields:
\begin{itemize}
    \item $P[\mathtt{LOCALS}][x] = \{\mathsf{Loc}(l_1)\}$.
    \item $P[\mathsf{Loc}(l_1)][\star] = \{\mathsf{Imm}(\mathtt{int})\}$.
    \item After \texttt{append}, $D[\mathsf{Loc}(l_1)] = \{\star\}$.
    \item After $y = x$, $P[\mathtt{LOCALS}][y] = \{\mathsf{Loc}(l_1)\}$.
    \item $\mathsf{DirtyRoots}(\Sigma,\mathsf{Live}_{l,i}) = \{x,y\}$.
\end{itemize}
Thus, both \texttt{x} and \texttt{y} are marked as roots for checkpointing.
