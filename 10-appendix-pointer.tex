\newcommand{\defeq}{\overset{\text{\tiny def}}{=}}

\begin{figure*}[t]
\centering

\begin{minipage}[t]{0.32\textwidth}
\centering
\textbf{Pointer Domain ($P$)}
\begin{gather*}
P \in \mathcal{P} = \mathcal{O} \to (\mathcal{K} \to 2^{\mathcal{O}}) | \bot_\mathcal{P} \\[0.3em]
P_1 \sqsubseteq P_2 \iff \forall o.\; P_1[o] \subseteq P_2[o] \\[0.3em]
(P_1 \sqcup P_2)[o] = P_1[o] \cup P_2[o] \\
\end{gather*}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.32\textwidth}
\centering
\textbf{Type Domain ($T$)}
\begin{gather*}
T \in \mathcal{T} = \mathcal{O} \to \mathit{TypeExpr} | \bot_\mathcal{T} \\[0.3em]
T_1 \sqsubseteq T_2 \iff \forall o.\; T_1[o] \leq: T_2[o] \\[0.3em]
(T_1 \sqcup T_2)[o] = T_1[o] \sqcup T_2[o]
\end{gather*}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.32\textwidth}
\centering
\textbf{Dirty Domain ($D$)}
\begin{gather*}
D \in \mathcal{D} = \mathcal{O} \to 2^{\mathcal{K}} | \bot_\mathcal{D} \\[0.3em]
D_1 \sqsubseteq D_2 \iff \forall o.\; D_1[o] \subseteq D_2[o] \\[0.3em]
(D_1 \sqcup D_2)[o] = D_1[o] \cup D_2[o]
\end{gather*}
\end{minipage}

\vspace{1.5em}

\noindent\textbf{Combined domain ($\Sigma$)}
\begin{align*}
\Sigma &= (P,T,D) \in \mathcal{P} \times \mathcal{T} \times \mathcal{D} | \bot_\Sigma\\[0.3em]
\Sigma_1 \sqsubseteq \Sigma_2 &\iff P_1 \sqsubseteq P_2 \land T_1 \sqsubseteq T_2 \land D_1 \sqsubseteq D_2 \\[0.3em]
\Sigma_1 \sqcup \Sigma_2 &= (P_1 \sqcup P_2,\; T_1 \sqcup T_2,\; D_1 \sqcup D_2)
\end{align*}

\caption{Abstract domains for heap analysis combining pointer tracking, type information, and mutation tracking.}
\label{fig:abstract-domains}
\end{figure*}

\newpage
\section{Pointer Analysis}
\label{sec:appendix-pointer}

\subsection{Scope and Goal}

The pointer analysis abstracts heap shape, aliasing, and mutations over the \spytecode IR
(\autoref{sec:appendix-tac-ir}) to support checkpointing. It is
flow-sensitive and intraprocedural along exception-free paths.
Instructionâ€“level effects (allocation at \textsf{Bind}, \textsf{ConstructTuple},
\textsf{ConstructDict}, \textsf{Call}, and iteration in \textsf{Unpack}) are interpreted here.
Callable \emph{invocation} effects come from the type system
(\autoref{sec:appendix-typesystem}) as an effect triple
\(\epsilon^\#=(\mathsf{new},\mathsf{update},\mathsf{points\_to\_args})\) and are translated to
heap updates by the transfer functions below.

\subsection{Notation and State}

We write basic blocks \(l\in L\) and instruction positions \(i\) within block \(l\), giving a
program point \(l\).
Variables are split into named locals \(\mathcal{V}_{\mathrm{named}}\) and stack stack variables
\(\mathcal{V}_{\mathrm{stack}}=\{\$0,\$1,\ldots\}\).
Let \(\mathsf{Live}_{l,i}\subseteq \mathcal{V}_{\mathrm{named}}\) be liveness at \(l\).

\paragraph{Abstract objects and fields.}
Abstract objects \(\mathcal{O}\) include
\begin{enumerate}
    \item \textsf{Loc}(l) --- allocation site.
    \item \textsf{Param}(p) --- external input.
    \item \textsf{Imm}($\tau$) --- immutable of type $\tau$.
    \item scopes ---\tLOCALS, \tGLOBALS.
\end{enumerate}

Fields \(\mathcal{K}\) are keys from the IR:
\(\mathsf{name}(s)\), \(\mathsf{index}(n)\), \(\mathsf{both}(n,s)\), and \(\star\) (wildcard).

\paragraph{Abstract domains (cf.\ Fig.~\ref{fig:abstract-domains}).}
The analysis state is \(\Sigma=(P,T,D)\) where
\[
P:\mathcal{O}\to\mathcal{K}\to 2^{\mathcal{O}},\qquad
T:\mathcal{O}\to \mathit{TypeExpr},\qquad
D:\mathcal{O}\to 2^{\mathcal{K}}.
\]
We use componentwise orders and joins; \(\bot_{\mathcal{P}}[o][f]=\emptyset\),
\(\bot_{\mathcal{T}}[o]=\bot_{\mathrm{Type}}\), \(\bot_{\mathcal{D}}[o]=\emptyset\).

\paragraph{Conventions.}
We store named locals and stack variables as fields of roots:
\(P[\mathtt{LOCALS}][\mathsf{name}(x)]\) for \(x\in\mathcal{V}_{\mathrm{named}}\),
and \(S[\mathsf{index}(\$k)]\) for \(\$k\in\mathcal{V}_{\mathrm{stack}}\).
We write \(O_x\) for a set of objects and \(\biguplus\) for union over a family.

\subsection{Auxiliary Updates}

Weak/strong update on points-to:
\[
\mathsf{Upd}(P,O_{\mathrm{tgt}},f,O_{\mathrm{new}})=
\begin{cases}
\text{for the unique }o\in O_{\mathrm{tgt}}:~P[o][f]\leftarrow O_{\mathrm{new}} & \text{if }|O_{\mathrm{tgt}}|=1\\
\text{for all }o\in O_{\mathrm{tgt}}:~P[o][f]\leftarrow P[o][f]\cup O_{\mathrm{new}} & \text{otherwise}
\end{cases}
\]
Dirty update: \(\mathsf{UpdD}(D,O_{\mathrm{tgt}},f)\) adds \(f\) to \(D[o]\) for each \(o\in O_{\mathrm{tgt}}\).

\smallskip
We use two auxiliary resolvers:
\[
\mathsf{RetObjects}(l,i,\epsilon^\#,\overline{O_a}) =
\begin{cases}
\{\mathsf{Loc}(l)\} & \text{if }\epsilon^\#.\mathsf{new}=\mathsf{true}\\
\Big(\biguplus_k O_{a_k}\Big)\ \cup\ \{\mathsf{Ret}^\uparrow\} & \text{otherwise}
\end{cases}
\]
(where \(\mathsf{Ret}^\uparrow\) is a distinguished summary return object),
and a target resolver for effect updates that follows argument/receiver links on bound callables:
\[
\mathsf{Targets}(P, O_f, \text{slot}) \subseteq \mathcal{O}
\quad\text{(slot is receiver or an argument index)}.
\]

\subsection{Transfer Functions for \spytecode}
\label{subsec:transfers}

The abstract state is a four-tuple \(\Sigma = (P,T,D,S)\) where \(P\) is the heap
points-to map, \(T\) the object-type map, \(D\) the dirty-field map, and \(S\) the
stack map for stack variables \(\$k\).
We write \(S[d \mapsto O]\) for functional update, and
\(\biguplus\mathcal{X}\) for set union over a family \(\mathcal{X}\).
Heap updates use
\(\mathsf{Upd}(P,\ O_{\mathrm{tgt}},\ f,\ O_{\mathrm{new}})\)
(weak/strong update depending on \(|O_{\mathrm{tgt}}|\)),
and dirty marks use
\(\mathsf{UpdD}(D,\ O_{\mathrm{tgt}},\ f)\).
Let \(\mathsf{Loc}(l)\) denote the allocation site at instruction index \(l\).
Pure operations never mutate \(P\); the stack map \(S\) changes only for
instructions that assign to a stack .
\subsection{Transfer Functions for \spytecode}
\label{subsec:transfers}

The abstract state is a four-tuple \(\Sigma=(P,T,D,S)\) where \(P\) is the heap
points-to map, \(T\) the object-type map, \(D\) the dirty-field map, and \(S\)
the stack map for stack variables.  Pure operations never mutate \(P\).  Only
instructions that assign to a destination stack variable can mutate \(S\).

\begin{figure*}[t]
\centering
\begin{align*}
% ===================== A. DATA MOVEMENT / NAME ACCESS =====================
&\textbf{(A) Data movement}\\
&Trans^\#\big((P,T,D,S),\ Mov(\$d,\$s)\big)
  = (P,\ T,\ D,\ S\llbracket d \mapsto S[s]\rrbracket)
\\[0.6em]
% ===================== B. PURE RESOLUTION =====================
&\textbf{(B) Constant lookup}\\
&Trans^\#\big((P,T,D,S),\ LoadConst(\$d,c)\big)
  = (P,\ T,\ D,\ S\llbracket d \mapsto \{Imm(type(c))\}\rrbracket)
\\
&Trans^\#\big((P,T,D,S),\ LookupDunder(\$d,op,\$a)\big)=(P,T,D,S\llbracket d \mapsto lookup\_dunder(T, op, S[\overline{\$a}])\rrbracket)
\\
&Trans^\#\big((P,T,D,S),\ ResolveOverload(\$d,\$f,\$a,\$k)\big)=(P,T,D,S\llbracket d \mapsto resolve\_overload(T, m, S[\$a], S[\$k])\rrbracket)
\\[0.6em]
% ===================== C. ATTRIBUTES (PURE W.R.T. HEAP) =====================
&\textbf{(C) Attribute read and named variable access (pure w.r.t.\  heap)}\\
&Trans^\#\big((P,T,D,S),\ GetAttr(\$d,\$o,f)\big)
  = \big(P,\ T,\ D,\ S\llbracket d \mapsto Attr(P,S[o],f)\rrbracket\big)
\\
&Trans^\#\big((P,T,D,S),\ LoadLocal(\$d,x)\big)
  = (P,\ T,\ D,\ S\llbracket d \mapsto P[LOCALS][name(x)]\rrbracket)
\\
&Trans^\#\big((P,T,D,S),\ LoadGlobal(\$d,x)\big)
  = (P,\ T,\ D,\ S\llbracket d \mapsto P[GLOBALS][name(x)]\rrbracket)
\\[0.6em]
% ===================== D. ALLOCATION SCHEMATA =====================
&\textbf{(D) Allocation schemata (allocate \& wire, then write stack)}\\
&Trans^\#\big((P,T,D,S),\ ConstructTuple(\$d,\overline{\$e}),\ q\big)
  = \big(P',\ T',\ D,\ S\llbracket d \mapsto \{\,Loc(q)\,\}\rrbracket\big)
\\[-0.1em]
&\hspace{4.45cm}\text{where}\quad (P',T') \;\defeq\; AllocTuple(P,T,Loc(q),\ \langle S[\overline{\$e}]\rangle)
\\[0.25em]
&Trans^\#\big((P,T,D,S),\ ConstructDict(\$d,\overline{(\$k,\$v)}),\ q\big)
  = \big(P'',\ T'',\ D,\ S\llbracket d \mapsto \{\,Loc(q)\,\}\rrbracket\big)
\\[-0.1em]
&\hspace{4.45cm}\text{where}\quad (P'',T'') \;\defeq\; AllocDict(P,T,Loc(q),\ \langle \overline{(S[\$k],S[\$v])}\rangle)
\\[0.25em]
&Trans^\#\big((P,T,D,S),\ Bind(\$d,\$f,\$a,\$k),\ q\big)
  = \big(P''',\ T''',\ D,\ S\llbracket d \mapsto \{\,Loc(q)\,\}\rrbracket\big)
\\[-0.1em]
&\hspace{4.45cm}\text{where}\quad (P''',T''') \;\defeq\; AllocBind(P,T,Loc(q),\ S[a],\ S[k])
\\[0.6em]
% ===================== E. SIDE-EFFECTING OPERATIONS =====================
&\textbf{(E) Heap updates via fields and calls}\\
&Trans^\#\big((P,T,D,S),\ SetLocal(x,\$s)\big)
  = \big(Upd(P,\{LOCALS\},name(x),S[s]),\ T,\ D,\ S\big) \\
&Trans^\#\big((P,T,D,S),\ Unpack(\overline{\$d},\$s)\big)
  = \big(P,\ T,\ D,\ S'\big)
\qquad\text{where}\quad
S'[d_j] \;\defeq\; Ind(P,S[s],j) \\
&Trans^\#\big((P,T,D,S),\ SetAttr(\$o,f,\$v)\big)
  = \big(Upd(P,S[o],name(f),S[v]),\ T,\ UpdD(D,S[o],name(f)),\ S\big)
\\
&Trans^\#\big((P,T,D,S),\ Call(\$d,\$f),\ q\big)
  = \big(P^\ast,\ T^\ast,\ D^\ast,\ S\llbracket d \mapsto O_{\mathrm{res}}\rrbracket\big)
\\[-0.3em]
&\hspace{4.45cm}\text{where}\quad (P^\ast,T^\ast,D^\ast,O_{\mathrm{res}})\ \defeq\ Invoke(P,T,D;\ Effect(\$f),\ S[f],\ Args(P,S[f],S),\ q)
\\[0.6em]
% ===================== F. CONTROL =====================
&\textbf{(F) Control (no state change)}\\
&Trans^\#\big((P,T,D,S),\ AssumeEq(\$b,\$c)\big)=(P,T,D,S),
\\
&Trans^\#\big((P,T,D,S),\ Exit\big)=(P,T,D,S)
\end{align*}

\caption{Abstract transformer \(Trans^\#\).
Only destination-producing instructions write to the stack map \(S\).
Heap \(P\) is mutated at allocation sites (\textsc{ConstructTuple}, \textsc{ConstructDict}, \textsc{Bind}), explicit writes (\textsc{SetLocal}, \textsc{SetAttr}), and via \textsc{Call} according to the effect summary \(\epsilon^\#\).
Lookup/overload resolution is pure.}
\label{fig:tac-transfers}
\end{figure*}

\begin{figure*}[t]
\centering
\begin{align*}
\begin{array}{ll}
Attr(P,O,f) &\defeq\ \displaystyle\biguplus_{o\in O} P[o][name(f)]
\\[0.2em]
Ind(P,O,j) &\defeq\ \displaystyle\Big(\biguplus_{o\in O} P[o][index(j)]\Big)\ \cup\ \Big(\biguplus_{o\in O} P[o][\star]\Big)
\\[0.2em]
AllocTuple(P,T,t,\langle O_0,\ldots,O_{n-1}\rangle)
  &\defeq\ \Big(P[t][index(j)] \supseteq O_j,\ P[t][\star]\supseteq O_j\ \forall j;\ \ T[t]\ \sqcup=\ TupleType(\langle O_j\rangle)\Big)
\\[0.2em]
AllocDict(P,T,d,\langle (K_m,V_m)\rangle_{m=1}^M)
  &\defeq\ \Big(P[d][name(s)] \supseteq V_m\ \text{if } K_m=\{\,Imm(\texttt{str}(s))\,\};\ \ P[d][\star]\supseteq V_m\ \text{otherwise};\ \ T[d]\ \sqcup=\ DictType(\langle K_m,V_m\rangle)\Big)
\\[0.2em]
AllocBind(P,T,b,O_a,O_k)
  &\defeq\ \Big(P[b][\texttt{"args"}]\supseteq O_a,\ P[b][\texttt{"kwargs"}]\supseteq O_k;\ \ T[b]\ \sqcup=\ ResidualCallableType(b)\Big)
\\[0.2em]
Args(P,O_f,S)
  &\defeq\ \text{actual argument objects resolved from }S\text{ and binding edges hanging off }O_f
\\[0.2em]
Effect(\$f)
  &\defeq\ \text{the effect summary }\epsilon^\#\text{ retrieved from the type component at }\$f
\\[0.2em]
Invoke(P,T,D;\ \epsilon^\#,O_f,\overline{O_a},q)
  &\defeq\ \text{apply }\epsilon^\#\text{: allocate results (fresh site } Loc(q)\text{ if needed),}\\
  &\qquad\text{propagate aliasing (}\star\text{ edges) when }\epsilon^\#.\textsf{points\_to\_args},\ \text{and perform field updates}\\
  &\qquad\text{on targets discovered by }Targets(P,O_f,\cdot)\text{ using } Upd \text{ and } UpdD; \text{ also update }T.
\end{array}
\end{align*}
\caption{Helper definition for abstract transformer.}
\label{fig:tac-transfers-helpers}
\end{figure*}

\paragraph{Notes.}
(i) \emph{Lookup purity.} Results of \(LookupDunder\)/\(ResolveOverload\) are static; we leave \(S\) unchanged and rely on the type component to constrain subsequent \(Bind/Call\).
(ii) \emph{Binding vs.\ calling.} \(Bind\) allocates a bound-callable object \(b\) with explicit \texttt{args}/\texttt{kwargs} edges; \(Call\) interprets \(\epsilon^\#\) to allocate results, propagate aliasing, and perform effect-guided updates on receivers/arguments discovered via \(Targets\).
(iii) \emph{Subscriptions.} Indexing sugar lowers to \(\_\_getitem\_\_\)/\(\_\_setitem\_\_\) and thus uses the same \(Bind/Call\) machinery.

\subsection{Reachability, Pruning, and Dirty Roots}

Roots at \(l\) are
\(R_{l,i}=\{\,P[\mathtt{LOCALS}][\mathsf{name}(x)] \mid x\in \mathsf{Live}_{l,i}\,\}\).
Reachability is the least fixed point
\[
\mathsf{Reach}(R,P)=\mu X.\ R\ \cup\ \{\,o' \mid \exists\,o\in X,\, f\in\mathcal{K}.\ o'\in P[o][f] \,\}.
\]
Abstract GC restricts to \(S=\mathsf{Reach}(R_{l,i},P)\):
\[
\mathsf{GC}(\Sigma,R_{l,i})=(P|_S,\ T|_S,\ D|_S).
\]
Dirty roots:
\[
\mathsf{DirtyRoots}(\Sigma,R_{l,i})=\big\{\, x\in \mathsf{Live}_{l,i}\ \big|\ \exists o\in \mathsf{Reach}(\{P[\mathtt{LOCALS}][\mathsf{name}(x)]\},P).\ D[o]\neq \emptyset \,\big\}.
\]

\subsection{Soundness}

Let \(\gamma\) map abstract states to sets of concrete heaps. Soundness requires:
\[
\forall \Sigma^\#=(P,T,D),\ \forall H\in \gamma(\Sigma^\#),\ \forall o,f.\quad H(o).f \in P[o][f].
\]
Whenever the concrete semantics performs a write \(o.f\leftarrow v\), the abstract transformer must
mark \(f\in D[o]\). Monotonicity of transformers and the product lattice yields a standard
worklist fixpoint and a post-fixpoint invariant. Local simulation lemmas follow the \spytecode
operational semantics (lookups are pure; \(\mathsf{Bind}/\mathsf{Construct*}/\mathsf{Call}/\mathsf{Unpack}\) introduce only the abstract updates shown above).
