\begin{figure}[t]
    \centering
    \input{pipeline.tex}
    \caption{Analysis pipeline. Python source is compiled to bytecode, lowered to TAC, and analyzed in three interacting domains.}
    \label{fig:overview}
\end{figure}

\section{Analysis}
\label{sec:analysis}

Our static analysis framework combines several interacting domains to determine the minimal set of program variables that must be included in a checkpoint.  
We present the domains in an order that matches their conceptual dependencies, starting from the IR, then moving to liveness, explaining objects, and general domain conventions before introducing the specific domains for dirty tracking, pointers, and types. Figure~\ref{fig:overview} shows the full pipeline, from source code through IR, liveness, and the reduced product, to the extracted invariants used for checkpoint minimization.

\subsection{Intermediate Representation}
Our analyses operate not on Python source or bytecode directly, but on a simplified register-based \emph{three-address code} (TAC).
This IR is designed to make dataflow and heap accesses explicit, removing the operand stack of Python bytecode and any implicit temporaries.
A TAC program consists of a finite set of \emph{labels} $L$, each with an associated basic block of instructions.
Each instruction reads and writes explicit \emph{variables} $v \in \mathcal{V}$, which may be:
\begin{itemize}
    \item \emph{Named locals} (e.g.\ \texttt{x}, \texttt{result}), corresponding to function parameters and Python local variables.
    \item \emph{Stack variables} ($\$0, \$1, \ldots$), introduced during translation to replace Python's stack slots.
\end{itemize}
Control flow is represented explicitly in a \emph{control-flow graph} (CFG) $G = (L, E)$ with directed edges for possible execution paths.
We write $\mathsf{succ}(l)$ and $\mathsf{pred}(l)$ for the successors and predecessors of a label $l$ in $G$.
An \emph{instruction location} is denoted by $(l, i)$ for the $i$-th instruction in block $l$.
\subsection{Liveness Analysis}
Liveness analysis determines, for each program point, the set of TAC variables whose current value may be read along some future control-flow path before being overwritten.  
We compute liveness as a standard backward dataflow analysis on the TAC, with the set of live variables at a location $(l,i)$ denoted $\mathsf{Live}_{l,i} \subseteq \mathcal{V}$.

Related: \cite{pythonsemantics}.

\paragraph{Gen/Kill sets.}
For each instruction, we define:
\begin{itemize}
    \item $\mathsf{gen}$: the set of variables read by the instruction (whose current value is needed now).
    \item $\mathsf{kill}$: the set of variables definitely overwritten by the instruction (whose current value is no longer needed).
\end{itemize}
The backward transfer function is:
\[
\mathsf{Live}_{\mathrm{in}} = (\mathsf{Live}_{\mathrm{out}} \setminus \mathsf{kill}) \cup \mathsf{gen}.
\]
A variable in $\mathsf{kill}$ is said to be \emph{killed} at that instruction.

\paragraph{Variable kinds.}
Variables in $\mathcal{V}$ come in two forms:
\begin{itemize}
    \item \emph{Stack variables} ($\$0, \$1, \ldots$) are compiler-generated temporaries that exist only within a single basic block and cannot be addressed once they are dead.  
          Killing such a variable immediately removes any heap objects reachable from it from the root set.
    \item \emph{Named local variables} (e.g.\ \texttt{x}, \texttt{result}) persist for the duration of a function activation and may, in Python, be captured by closures or declared \texttt{nonlocal}.
          We restrict our target program subset to disallow such captures, so a named local can be considered dead when no further reads occur in the current function body.
\end{itemize}

\paragraph{Role in later domains.}
The live-variable set at each point is used to prune the root set for the pointer graph: when a variable $v$ is not live, all edges reachable only through $v$ are removed.
This prevents dead variables from keeping otherwise unreachable objects alive in the analysis state.

\subsection{Objects and Fields}
We model the heap as a finite set of \emph{abstract objects} $\mathcal{O}$, each representing either:
\begin{itemize}
    \item A distinguished \emph{root object} such as \texttt{LOCALS} or \texttt{GLOBALS}.
    \item A \emph{parameter object} representing a function argument at entry.
    \item An \emph{allocation site object} $o_{l,i}$ created by a specific instruction location $(l, i)$.
\end{itemize}
Objects have \emph{fields} $f \in \mathcal{F}$ representing attributes, dictionary keys, or sequence elements.
For collections, we use a wildcard field $\star$ to conservatively represent all indexed elements.
Accessing \texttt{x.f} refers to field $f$ of the object(s) currently bound to variable $x$.

We will write $P[o][f]$ for the set of target objects stored in field $f$ of object $o$ in the pointer graph (defined later), and $D[o]$ for the set of fields of $o$ that are currently dirty.

\subsection{Map Domains}
Many of our domains are \emph{maps}, i.e.\ finite partial functions $M : K \to V$ with a fixed \emph{default value} $\bot_V$ for missing keys.
We adopt a uniform notation and semantics for their use in abstract interpretation:
\begin{itemize}
    \item \textbf{Transfer:} An assignment to key $k$ replaces $M[k]$ with a new value $v$.
    \item \textbf{Weak update:} If $k$ may alias with other keys, we conservatively set $M[k] \leftarrow M[k] \sqcup v$ instead of overwriting.
    \item \textbf{Join:} $(M_1 \sqcup M_2)[k] = M_1[k] \sqcup M_2[k]$ for all $k$ in the union of their domains.
    \item \textbf{Subsumption:} $M_1 \sqsubseteq M_2$ if $M_1[k] \sqsubseteq M_2[k]$ for all $k$ in the union of their domains.
\end{itemize}
We treat missing keys as implicitly mapped to $\bot_V$ for the purposes of all operations above.
In our analyses, the value type $V$ may itself be another map, a set of objects, or a simple lattice such as booleans, making this pattern reusable across domains.

\subsection{Dirty Domain}
The \emph{dirty} domain maps each object to the set of fields written since the last checkpoint.
An update marks the corresponding field as dirty; deletions are treated as writes.
The domain itself does not decide which dirty objects must be checkpointed—this decision is deferred until pointer reachability and liveness are taken into account.
\subsection{Pointer Domain}
The \emph{pointer domain} models the shape of the heap as a map
\[
P : \mathcal{O} \to (\mathcal{F} \to \mathcal{P}(\mathcal{O}))
\]
where $P[o][f]$ is the set of abstract objects that may be stored in field $f$ of object $o$.
The inner map has default value $\emptyset$ for any field not explicitly present.

\paragraph{Transfer.}
On an instruction that stores a reference into a field---for example \texttt{x.f = y}---we first resolve the set of possible source objects $S$ for $y$ and the set of possible target objects $T$ for $x$.
For each $t \in T$, we update $P[t][f]$ with $S$.
If $t$ is known to be the only object bound to $x$ (no aliasing), we perform a \emph{strong update}:
\[
P[t][f] \leftarrow S.
\]
If aliasing is possible, we perform a \emph{weak update}:
\[
P[t][f] \leftarrow P[t][f] \cup S.
\]
Reads, such as \texttt{y = x.f}, do not change $P$ but are resolved by looking up $\bigcup_{t \in T} P[t][f]$.

\paragraph{Join and Subsumption.}
The join $P_1 \sqcup P_2$ is computed pointwise over objects and fields, taking the union of target sets.
Subsumption $P_1 \sqsubseteq P_2$ holds if $P_1[o][f] \subseteq P_2[o][f]$ for all $o \in \mathcal{O}$ and $f \in \mathcal{F}$.

\paragraph{Reachability.}
Given a set of \emph{root objects} $R \subseteq \mathcal{O}$ (typically \texttt{LOCALS} and \texttt{GLOBALS}), the set of \emph{reachable objects} $\mathsf{Reach}(R, P)$ is the smallest set containing $R$ and closed under:
\[
o \in \mathsf{Reach}(R, P) \wedge o' \in P[o][f] \implies o' \in \mathsf{Reach}(R, P).
\]
We use liveness to prune the roots $R$ before reachability is computed, ensuring that dead variables do not keep their objects alive.

\subsection{Type and Effect Domain}

Our type domain models Python values using a small set of constructs chosen to match the subset of Python we target: nominal classes, structural protocols, callable signatures, container types, and the special \texttt{any} type for unknown values.
Unlike general--purpose type systems, we unify the representation of parameter lists and object fields as \emph{rows}: finite ordered maps from keys (positional indices or names) to types.  
This gives a single mechanism for lookup, subtyping, joining, and unification across functions, classes, and modules.

Functions are annotated with \emph{effects} that describe their interactions with the heap: whether they allocate new objects, return existing ones, or update fields.  
These effects are directly consumed by the checkpointing analysis to determine which heap locations may be modified and which can be safely excluded from checkpoints.

\paragraph{Main type constructs.}
The principal forms in our type language (full syntax in Appendix~\ref{sec:appendix-typesystem}) are:
\begin{itemize}
  \item \textbf{Classes} $\mathsf{class}(C, R, \overline{\tau}, \overline{\alpha})$:
        a nominal class $C$ with row $R$ of fields and optional generic parameters $\overline{\alpha}$.
  \item \textbf{Protocols} $\mathsf{protocol}(R, \overline{\alpha})$:
        structural interfaces requiring the listed fields with given types, independent of nominal identity.
  \item \textbf{Modules}:
        rows of exported names and their types.
  \item \textbf{Functions} $\forall \overline{X}.\;R_{\mathrm{params}} \xrightarrow{\epsilon} \tau_{\mathrm{ret}}$:
        with parameter row $R_{\mathrm{params}}$, return type $\tau_{\mathrm{ret}}$, and effect $\epsilon$.
        Functions may appear in overload sets.
  \item \textbf{Other forms}:
        unions, generic instantiations, variadic packs for \texttt{*args}-style functions, and \texttt{any}.
\end{itemize}

\paragraph{Rows and subtyping.}
A row is a finite sequence of fields indexed by name or position.  
Width subtyping applies: a type with extra fields is a subtype of one with fewer fields, provided all shared fields match.  
Protocols are a special case: any object with the required fields is a subtype, regardless of its nominal class.

\paragraph{Call checking and binding.}
When a call is type--checked, argument types are unified with the corresponding parameter types:
\begin{itemize}
  \item Type variables may be solved, yielding a substitution applied to all remaining parameters and the return type.
  \item Parameters matched by the call are removed, producing either a \emph{residual callable} (for partial application) or the substituted return type.
  \item Variadic packs (\texttt{*args}) may be partially bound and matched incrementally; if unmatched packs remain, the result is again a residual callable.
\end{itemize}
Overloaded functions are handled by attempting binding against each arm independently; the results are joined when ambiguity remains.  
The formal residual--callable construction is given in Appendix~\ref{sec:appendix-typesystem}.

\paragraph{Effects.}
Effects annotate functions with heap interactions:
\begin{itemize}
  \item \textbf{\texttt{new}}: allocates a fresh object.
  \item \textbf{\texttt{points-to}}: returns a reference to an existing object.
  \item \textbf{\texttt{update}}: modifies or refines a specific field, possibly changing its type.
\end{itemize}
Updates are instantiated with actual arguments. For example, from the builtins stub:

\begin{lstlisting}[language=python]
@update(list[T | Q], 1)
def append[Q](self: list[T], x: Q) -> None: ...
\end{lstlisting}

If \texttt{self} initially has type \texttt{list[$\bot$]} and we call \texttt{append} with an \texttt{int}, the element type refines to \texttt{$\bot \sqcup$ list[$\bot$]} which is \texttt{list[int]}.  
Type-changing updates are only applied when the receiver is unaliased and monomorphic, preventing unsound refinements across aliases.

\paragraph{Field and attribute access.}
For $x.f$, the pointer domain yields possible receivers; their rows are inspected:
\begin{itemize}
  \item If all agree on the field type, that type is returned.
  \item If types disagree, their join is returned.
  \item If the field is missing, join with the residual row's default (often \texttt{any}) and mark as possibly failing.
\end{itemize}

\paragraph{Example: partial application and update.}
Consider:
\[
f : \forall T,U.\; (0:T, 1:U) \to T
\]
Calling $f$ with an \texttt{int} yields a residual $(0:U) \to \texttt{int}$.  
Calling this residual with a \texttt{str} then yields a residual  $() \to \texttt{int}$; finally, retrieving the result yields an \texttt{int}.  
Similarly, \texttt{list.append} with an \texttt{int} argument refines the element type from unknown to \texttt{int}.

\paragraph{Precision and limits.}
The type system can:
\begin{enumerate}
  \item Identify exactly which heap locations an operation may modify.
  \item Exclude immutable structures from checkpoints.
  \item Refine container element types across updates.
\end{enumerate}
Precision loss occurs when joins force widening to \texttt{any} (e.g., differing field types, many unknowns, or unknown attribute names).  
Dynamic features such as monkey--patching, dynamic imports, or metaclass manipulation are excluded from the target subset.

\subsection{Domain Interactions}
The domains operate in a reduced product with directed information flow:
\begin{itemize}
    \item \emph{Liveness $\rightarrow$ Pointer:} prunes unreachable roots and their edges.
    \item \emph{Type $\rightarrow$ Pointer:} constrains possible targets based on type-level field shape.
    \item \emph{Type $\rightarrow$ Dirty:} immutable objects never become dirty.
    \item \emph{Pointer $\rightarrow$ Type:} dynamic dispatch resolution is narrowed to types of reachable receivers.
\end{itemize}
These interactions improve precision by removing impossible states before they can pollute other domains.

\subsection{Transfer Functions}
For each TAC instruction, the transfer function updates only the affected keys in each domain according to the instruction’s semantics.
Weak updates are applied when aliasing is possible, and joins are used when merging control-flow paths.
The set of checkpoint roots at loop boundaries is obtained by intersecting live roots with reachable dirty objects.

